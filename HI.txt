Write a Modular C Programming Code for the Sum & Avg of a 1D Array?

#include<stdio.h>

void readArray(int[],int);
void displayArray(int[],int);
int sumArray(int[],int);

int main()
{
int n,s ;
double avg;
int arr[100];
printf("Enter the size of Array: ");
scanf("%d",&n);
printf("Enter the elements of array: \n");
readArray(arr,n);
s=sumArray(arr,n);
printf("The Sum of Array is : %d\n",s);
avg=(double)s/n;
printf("The Avarage of Array is : %lf\n",avg);

}

void readArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
scanf("%d",&arr[i]);
}
}

void displayArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
printf("%d ",arr[i]);
}
}

int sumArray(int arr[],int n)
{
int i, sum=0;
for(i=0;i<n;i++)
{
sum=sum+arr[i];
}
return sum;
}





Here you go with the modular C programming code for the Min &Max of a 1D Array. Go through this C program to find the Min and Max of array elements using function.


#include<stdio.h>

void readArray(int[],int);
void displayArray(int[],int);
void minmaxArray(int[],int);

int main()
{
int n,s ;
int arr[100];
printf("Enter the size of Array: ");
scanf("%d",&n);
printf("Enter the elements of array: \n");
readArray(arr,n);
minmaxArray(arr,n);
}

void readArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
scanf("%d",&arr[i]);
}
}

void displayArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
printf("%d ",arr[i]);
}
}

void minmaxArray(int arr[],int n)
{
int min, max,i;
min=max=arr[0];
for(i=1; i<n; i++)
{
if(min>arr[i])
min=arr[i];
if(max<arr[i])
max=arr[i];
}
printf("minimum of array is : %d",min);
printf("\nmaximum of array is : %d",max);
}


Write a Modular C Programming Code for Linear Search of a 1D Array?



#include<stdio.h>

void readArray(int[],int);
int linear(int A[],int n,int key);

int main()
{
int n,occ,key;
int arr[100];
printf("Enter the size of Array: ");
scanf("%d",&n);
printf("Enter the elements of array: \n");
readArray(arr,n);
printf("Enter the elements to be searched in array: \n");
scanf("%d",&key);
occ=linear(arr,n,key);

if(occ>0)
{
printf("Search is successful!!!\n");
printf("Occurannce=%d\n",occ);
}
else
printf("Search not successful!!!\n");

}
 

void readArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
scanf("%d",&arr[i]);
}
}

void displayArray(int arr[],int n)
{
int i;
for(i=0;i<n;i++)
{
printf("%d ",arr[i]);
}
}

int linear(int arr[],int n,int key)
{
int i,occ=0;

for(i=0;i<n;i++)
{
if(key==arr[i])
{
occ++;
}
}
return(occ);
}


Write a Modular C Programming Code for Reading & Displaying of a 2D Array?

#include<stdio.h>
#define ROW 10
#define COL 10

void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);

main()
{
int r,c,sum;
int a[ROW][COL];
double avg;
printf("Enter the order of 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of Matix:\n");
ReadArray(a,r,c);
printf("\nThe Elements of Matix are\n");
DisplayArray(a,r,c);
}

void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}

void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d ",a[i][j]);
}
printf("\n");
}
}




Write a Modular C Programming Code for Sum & Avg of a 2D Array?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10
void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);
int SumMatrix(int [ROW][COL], int, int);

main()
{
int r,c,sum;
int a[ROW][COL];
double avg;
printf("Enter the order of 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of Matix:\n");
ReadArray(a,r,c);
printf("\nThe Elements of Matix are\n");
DisplayArray(a,r,c);
sum=SumMatrix(a,r,c);
printf("The SUM of the Matrix is: %d\n",sum);
avg=(double)sum/r*c;
printf("The Avg of the Matrix is: %lf\n",avg);
}

void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}

void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d ",a[i][j]);
}
printf("\n");
}
}

int SumMatrix(int a[ROW][COL], int r, int c)
{
int i,j,sum=0;

for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
sum=sum+a[i][j];
}

}
return sum;
}


Write a Modular C Programming Code for finding the Maximum & Minimum of a 2D Array?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10

void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);
void SumEachRow(int [ROW][COL], int, int);
void SumEachCol(int [ROW][COL], int, int);
void MinMaxArray(int [ROW][COL], int, int);
main()
{
int r,c,sum;
int a[ROW][COL];
double avg;
printf("Enter the order of 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of Matix:\n");
ReadArray(a,r,c);
printf("\nThe Elements of Matix are\n");
DisplayArray(a,r,c);
MinMaxArray(a,r,c);
}

void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}

void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d ",a[i][j]);
}
printf("\n");
}
}

void MinMaxArray(int a[ROW][COL], int r, int c)
{
int i,j,min=a[0][0] ,max=a[0][0];
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
if (a[i][j] > max)
{
max = a[i][j];
}
if (a[i][j] < min)
{
min = a[i][j];
}
}
}
printf("Min is: %d\n",min);
printf("Max is: %d\n",max);
}


Write a Modular C Programming Code for finding the Maximum & Minimum of a 2D Array?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10

void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);
void SumEachRow(int [ROW][COL], int, int);
void SumEachCol(int [ROW][COL], int, int);
void MinMaxArray(int [ROW][COL], int, int);
main()
{
int r,c,sum;
int a[ROW][COL];
double avg;
printf("Enter the order of 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of Matix:\n");
ReadArray(a,r,c);
printf("\nThe Elements of Matix are\n");
DisplayArray(a,r,c);
MinMaxArray(a,r,c);
}

void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}

void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d ",a[i][j]);
}
printf("\n");
}
}

void MinMaxArray(int a[ROW][COL], int r, int c)
{
int i,j,min=a[0][0] ,max=a[0][0];
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
if (a[i][j] > max)
{
max = a[i][j];
}
if (a[i][j] < min)
{
min = a[i][j];
}
}
}
printf("Min is: %d\n",min);
printf("Max is: %d\n",max);
}




Write a Modular C Programming Code for Transpose of a 2D Matrix?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10

void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);
void trans(int [ROW][COL],int [ROW][COL],int ,int) ;
main()
{
int r,c,sum;
int a[ROW][COL];
int b[ROW][COL];
printf("Enter the order of 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of Matix:\n");
ReadArray(a,r,c);
printf("\nThe Elements of Matix are\n");
DisplayArray(a,r,c);
trans(a,b,r,c);
}

void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}

void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("\t%d",a[i][j]);
}
printf("\n");
}
}

void trans(int a[ROW][COL], int b[ROW][COL], int r, int c)
{
int i,j ;
printf("Transpose of matrix: \n");
for (i=0;i<r;i++)
{
for (j=0;j<c;j++)
{
b[i][j]=a[j][i];
printf("\t%d",a[j][i]);
}printf("\n");
}
}

Write a Modular C Programming Code for Finding Norm of a 2D Matrix?
CODE:

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
void read(int A[10][10],int m,int n);
void display(int A[10][10],int m,int n);
float calnorm(int A[10][10],int m,int n);
main()
{
int A[10][10],i,j,m,n;
float norm=0;
printf("Enter order of the matrix\n");
scanf("%d%d",&m,&n);
if(m!=n)
{
printf("Invalid size of the matrix\n");
exit(0);
}
printf("Enter elements of the matrix\n");
read(A,m,n);
printf("Entered matrix is:\n");
display(A,m,n);
norm=calnorm(A,m,n);
printf("Norm of the given matrix is=%f\n",norm);
}
void read(int A[10][10],int m,int n)
{
int i,j;

for(i=0;i<m;i++)
for(j=0;j<n;j++)
scanf("%d",&A[i][j]);
}

void display(int A[10][10],int m,int n)
{
int i,j;
for(i=0;i<m;i++)
{
for(j=0;j<n;j++)
printf("%d\t",A[i][j]);

printf("\n");
}
return;
}
float calnorm(int A[10][10],int m,int n)
{
int i,j,sum=0;
float norm;

for(i=0;i<m;i++)
{
for(j=0;j<n;j++)
sum=sum+A[i][j]*A[i][j];
}
norm=sqrt(sum);
return(norm);
}



Write a Modular C Programming Code for Orthogonal of a 2D Matrix?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10
void readMatrix(int [ROW][COL],int ,int);
void displayMatrix(int [ROW][COL],int ,int);
void transposeMatrix(int a[ROW][COL],int r,int c, int b[ROW][COL]);
void matrixmultiplication(int a[ROW][COL],int R1,int C1,int b[ROW][COL], int res[ROW][COL]);
int identityMatrix(int a[ROW][COL],int r,int c);
main()
{
int r,c,i;
int a[ROW][COL];
int b[ROW][COL];
int res[ROW][COL]={0};
printf("Enter the order of matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the elements of matrix:\n");
readMatrix(a,r,c);
transposeMatrix(a,r,c,b);
matrixmultiplication(a,r,c,b,res);
i=identityMatrix(res,r,r);
if(i==1)
printf("\nIt is orthogonal matrix");
else
printf("\nNot orthogonal matrix");
}
void readMatrix(int a[ROW][COL],int r ,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
scanf("%d",&a[i][j]);
}
}
void displayMatrix(int a[ROW][COL],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
printf("%d\t",a[i][j]);
printf("\n");
}
}
void transposeMatrix(int a[ROW][COL],int r,int c, int b[ROW][COL])
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
b[j][i]=a[i][j];
}
}
}
void matrixmultiplication(int a[ROW][COL],int r,int c,int b[ROW][COL], int res[ROW][COL])
{
int i,j,k;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
for(k=0;k<c;k++)
{
res[i][j]=res[i][j]+a[i][k]*b[k][j];
}
}
}
}
int identityMatrix(int a[ROW][COL],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
if(i==j && a[i][j]!=1)
return 0;
if(i!=j && a[i][j]!=0)
return 0;
}
}
return 1;
}
OUTPUT

Enter the order of matrix: 3 3

Enter the elements of matrix:
6
4
8
9
5
2
7
6
4

Not orthogonal matrix
Process returned 0 (0x0) execution time : 10.516 s
Press any key to continue.


Write a Modular C Programming Code for Identity of a 2D Matrix?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10
void readMatrix(int [ROW][COL],int ,int);
void displayMatrix(int [ROW][COL],int ,int);
int identityMatrix(int a[ROW][COL],int r,int c);
main()
{
int r,c,i;
int a[ROW][COL];
int b[ROW][COL];
int res[ROW][COL]={0};
printf("Enter the order of matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of matrix:\n");
readMatrix(a,r,c);
printf("\nThe Given matrix is :\n");
displayMatrix(a,r,c);
i=identityMatrix(res,r,c);
if(i==1)
printf("\nIt is Identity matrix");
else
printf("\nNot Identity matrix");

}

void readMatrix(int a[ROW][COL],int r ,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
scanf("%d",&a[i][j]);
}
}
void displayMatrix(int a[ROW][COL],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
printf("%d\t",a[i][j]);
printf("\n");
}
}

int identityMatrix(int a[ROW][COL],int r,int c)
{
int i,j,flag=1;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
if(i==j && a[i][j]!=1)
flag=0;
else if(i!=j && a[i][j]!=0)
flag=0;

}
}
return flag;
}
OUTPUT

Enter the order of matrix: 3 3

Enter the Elements of matrix:
5
6
2
1
8
6
4
3
2

The Given matrix is :
5 6 2
1 8 6
4 3 2

Not Identity matrix
Process returned 0 (0x0) execution time : 8.883 s
Press any key to continue.





Write a Modular C Programming Code for Multiplication of a 2D Matrix?
CODE:

#include<stdio.h>
#include<math.h>
#define ROW 10
#define COLUMN 10
void readMatrix(int [ROW][COLUMN],int ,int);
void displayMatrix(int [ROW][COLUMN],int ,int);
void matrixmultiplication(int a[ROW][COLUMN],int R1,int C1,int[ROW][COLUMN],int R2, int C2, int res[ROW][COLUMN]);
int main()
{
int a[ROW][COLUMN];
int b[ROW][COLUMN];
int res[ROW][COLUMN]={0};
int R1,C1,R2,C2;
printf("Enter order of 1st matrix:\n");
scanf("%d%d",&R1,&C1);
printf("Enter order of 2nd matrix:\n");
scanf("%d%d",&R2,&C2);
if(C1!=R2)
{
printf("Matrix multiplication not possible\n");
exit(0);
}
printf("Enter elements of 1st Matrix:\n");
readMatrix(a,R1,C1);
printf("Enter elements of 2nd matrix:\n");
readMatrix(b,R2,C2);
matrixmultiplication(a,R1,C1,b,R2,C2,res);
printf("Matrix Array after multiplication:\n");
displayMatrix(res,R1,C2);
return 0;
}
void readMatrix(int a[ROW][COLUMN],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
scanf("%d",&a[i][j]);
}
}
void displayMatrix(int a[ROW][COLUMN],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d\t",a[i][j]);
}
printf("\n");
}
}
void matrixmultiplication(int a[ROW][COLUMN],int R1,int C1,int b[ROW][COLUMN],int R2, int C2, int res[ROW][COLUMN])
{
int i,j,k;
for(i=0;i<R1;i++)
{
for(j=0;j<C2;j++)
{
for(k=0;k<C1;k++)
{
res[i][j]=res[i][j]+a[i][k]*b[k][j];
}
}
}
}
OUTPUT

Enter order of 1st matrix:
3 3
Enter order of 2nd matrix:
3 3
Enter elements of 1st Matrix:
3
6
5
2
4
6
8
1
9
Enter elements of 2nd matrix:
2
3
5
4
6
2
7
9
1
Matrix Array after multiplication:
65 90 32
62 84 24
83 111 51

Process returned 0 (0x0) execution time : 23.400 s
Press any key to continue.




Write a Modular C Programming Code for Counting how many prime numbers are there in each row and coloumn of a 2D Matrix?
CODE:

#include<stdio.h>
#include<math.h>
#define ROW 10
#define COLUMN 10
void readMatrix(int [ROW][COLUMN],int ,int);
void displayMatrix(int [ROW][COLUMN],int ,int);
void countprimes(int [ROW][COLUMN],int ,int);
int primecount1Darray(int [],int);
int isprime(int);
int main()
{
int a[ROW][COLUMN];
int r,c;
printf("Enter rows and columns:\n");
scanf("%d%d",&r,&c);
printf("Enter array elements:\n");
readMatrix(a,r,c);
printf("Array is:\n");
displayMatrix(a,r,c);
countprimes(a,r,c);
return 0;
}
void readMatrix(int a[ROW][COLUMN],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
scanf("%d",&a[i][j]);
}
}
void displayMatrix(int a[ROW][COLUMN],int r,int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("%d\t",a[i][j]);
}
printf("\n");
}
}
void countprimes(int a[ROW][COLUMN],int r,int c)
{
int i,p;
for(i=0;i<r;i++)
{
p=primecount1Darray(a[i],c);
printf("number of prime in %dth row=%d\n",i,p);
}
}
int primecount1Darray(int b[],int n)
{
int i,p,count=0;
for(i=0;i<n;i++)
{
if(b[i]<=1)
continue;
p=isprime(b[i]);
if(p==1)
count++;
}
return count;
}
int isprime(int n)
{
int i;
for(i=2;i<=sqrt(n);i++)
{
if(n%i==0)
return 0;
}
return 1;
}
OUTPUT

Enter rows and columns:
3 3
Enter array elements:
5
6
3
2
4
8
9
6
5
Array is:
5 6 3
2 4 8
9 6 5
number of prime in 0th row=2
number of prime in 1th row=1
number of prime in 2th row=1

Process returned 0 (0x0) execution time : 8.161 s
Press any key to continue.




Write a Modular C Programming Code for Addition of a 2D Matrix?
CODE:

#include<stdio.h>
#define ROW 10
#define COL 10
void ReadArray(int [ROW][COL], int, int);
void DisplayArray(int [ROW][COL], int, int);
void SumMatrix(int [ROW][COL], int [ROW][COL], int [ROW][COL], int, int);
main()
{
int r,c,sum;
int a[ROW][COL];
int b[ROW][COL];
int z[ROW][COL];

printf("Enter the order of 1st 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of 1st Matix:\n");
ReadArray(a,r,c);
printf("Enter the order of 2nd 2D matrix: ");
scanf("%d%d",&r,&c);
printf("\nEnter the Elements of 2nd Matix:\n");
ReadArray(b,r,c);
SumMatrix(a,b,z,r,c);
printf("\nThe 1st Matrix is:\n");
DisplayArray(a,r,c);
printf("\nThe 2nd Matrix is:\n");
DisplayArray(b,r,c);
printf("\nThe Final Addition Matrix is\n");
DisplayArray(z,r,c);
}
void ReadArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
scanf("%d",&a[i][j]);
}
}
}
void DisplayArray(int a[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
printf("\t%d",a[i][j]);
}
printf("\n");
}
}

void SumMatrix(int a[ROW][COL],int b[ROW][COL],int z[ROW][COL], int r, int c)
{
int i,j;
for(i=0;i<r;i++)
{
for(j=0;j<c;j++)
{
z[i][j]=a[i][j]+b[i][j];
}
}
}
OUTPUT

Enter the order of 1st 2D matrix: 3 3

Enter the Elements of 1st Matix:
3
6
5
9
1
6
5
4
9
Enter the order of 2nd 2D matrix: 3 3

Enter the Elements of 2nd Matix:
3
6
2
5
4
9
2
1
7

The 1st Matrix is:
3 6 5
9 1 6
5 4 9

The 2nd Matrix is:
3 6 2
5 4 9
2 1 7

The Final Addition Matrix is
6 12 7
14 5 15
7 5 16

Process returned 0 (0x0) execution time : 24.845 s
Press any key to continue.


Write a Modular C Programming code for Reading, Displaying, and operations on files*
*The file should be saved in (student.txt) this Format in the location of this c file.
Rno   Name    CGPA
1     ABC      7
2     PQR      9
3     MNO      8
4     DEF      10

It will Display all student record who have got CGPA >= 8.5

Refer To Notes:  Notes: File Handling in C programming | Operations in Files

CODE:

#include<stdio.h>
#include<stdlib.h>
struct student
{
    int rno;
    char name[20];
    double cgpa;
};
void display(FILE *);
int main()
{
    FILE *fp1;
    fp1 = fopen("student.txt","r");
    if(fp1==NULL)
    {
        perror("");
        exit(0);
    }
    display(fp1);
    fclose(fp1);
    return 0;
}
void display(FILE *fp)
{
    struct student s;
    while(fscanf(fp,"%d%s%lf",&s.rno,s.name,&s.cgpa)==3)
    {
        if(s.cgpa>=8.5)
        {
            printf("%d\t%s\t%lf\n",s.rno,s.name,s.cgpa);
        }
    }
}



OUTPUT

2 PQR 9 
4 DEF 10

Process returned 0 (0x0)   execution time : 369.409 s
Press any key to continue.




C Programming File Handling | comparing two files in *files
by factsprime
Write a Modular C Programming code for Comparing two files on files*
*The file should be saved in (file1.txt & file2.txt) this Format in the location of this c file.
Below is the content of File:

FactsPrime

Refer To Notes:  Notes: File Handling in C programming | Operations in Files

CODE:

#include<stdio.h>
#include<stdlib.h>
void compareFiles(FILE *fp1, FILE *fp2)
{

    char ch1 = getc(fp1);
    char ch2 = getc(fp2);

    int error = 0;
    while (ch1 != EOF && ch2 != EOF)
    {
        if (ch1 != ch2)
        {
            error++;
            break;
        }
        ch1 = getc(fp1);
        ch2 = getc(fp2);
    }
    if(error>0)
        printf("Both the file content are not same\n ");
    else
        printf("Both the file content are same\n ");
}

main()
{
FILE *fp1;
FILE *fp2;
    fp1 = fopen("file1.txt", "r");
    fp2 = fopen("file2.txt", "r");

    if (fp1 == NULL || fp2 == NULL)
    {
       printf("Error : Files not open");
       exit(0);
    }

    compareFiles(fp1, fp2);
    fclose(fp1);
    fclose(fp2);
}

OUTPUT

It will Display Accordingly:
Both the file content are not same
or
Both the file content are same

Process returned 0 (0x0)   execution time : 369.409 s
Press any key to continue.





Write a Modular C Programming code for Copying one file to Another *file
*The file should be saved in (1.txt & copy.txt) this Format in the location of this c file.
Below is the content of File:

FactsPrime has helped me in learning c-programming! 

Refer To Notes:  Notes: File Handling in C programming | Operations in Files

CODE:

#include<stdio.h>
#include<stdlib.h>

void file_copy(FILE *, FILE *);

int main()
{
    FILE *fp1, *fp2;
    fp1 = fopen("1.txt","r");
    fp2 = fopen("copy.txt","w");
    if(fp1==NULL || fp2==NULL)
    {
        perror("");//same as printf, but perror will print compiler error message as well
        exit(0);
    }
    file_copy(fp1, fp2);
    fclose(fp1);
    fclose(fp2);
    return 0;
}

void file_copy(FILE *fp1, FILE *fp2)
{
    char ch;
    while((ch=getc(fp1))!=EOF)
        putc(ch, fp2);
}



OUTPUT

This will copy the content of file 1.txt to the copy.txt file. And saves it.

Process returned 0 (0x0)   execution time : 369.409 s
Press any key to continue.





Write a Modular C Programming code for Counting Total characters in *files
*The file should be saved in (1.txt) this Format in the location of this c file.
Below is the content of File:

Facts Prime is the #1 resource that provides not only the facts on science and ancient history.
but also is being involved in gathering a variety of codes in C programming for 
data structures and many more. This page has a unique feel,  
with efforts of constructed action figures representing the co-founders.

Refer To Notes:  Notes: File Handling in C programming | Operations in Files

CODE:

#include<stdio.h>
#include<stdlib.h>
/*
    Modular Program to count number of characters in a file
*/


#include
#include
long long int count(FILE *);
int main()
{
    FILE *fp1;
    fp1 = fopen("1.txt","r");
    if(fp1==NULL)
    {
        perror("");
        exit(0);
    }
    c = count(fp);
    printf("%lld\n",c);
    fclose(fp);
    return 0;
}

long long int count(FILE *fp)
{
    long long int c = 0;
    char ch;
    while((ch=getc(fp))!=EOF)
        c++;
    return c;
}

OUTPUT

308

Process returned 0 (0x0)   execution time : 369.409 s
Press any key to continue.







Write a Modular C Programming code for Storing Data into the File overwrite
A file will be created in the name computer.txt in the same location
Question) Vishal owns a cyber café, where he has ‘N’ number of computers stored in a file. Since Vishal is lazy to write the details of ‘N’ computers on paper, he stores the
details of computers in a file. Please help Vishal to store the details of the computers
and perform the below operations.
*Display the details of all computers.

Refer To Notes:  Notes: File Handling in C programming | Operations in Files

CODE:

#include<stdio.h>
#include<stdlib.h>
void write_to_file(FILE *p);
void read_from_file(FILE *p);
void computers_details(FILE *p);
int main()
{
    FILE *p;
    write_to_file(p);
    read_from_file(p);
    return 0;
}
void write_to_file(FILE *p)
{
     char computer_name[20];
    int ram,windows,i,n;
    p=fopen("computer.txt","w");
    printf("Enter the number of computers: ");
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n");

        printf("\nEnter the Details of computer %d: \n",i);
        printf("ENTER COMPUTER NAME: ");
        scanf("%s",computer_name);
        printf("ENTER THE RAM OF THE COMPUTER: ");
        scanf("%d",&ram);
        printf("ENTER THE WINDOWS VERSION: ");
        scanf("%d",&windows);
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++\n");
        fprintf(p,"\n%s\t%d\t%d\n",computer_name,ram,windows);
    }
    fclose(p);
}
void read_from_file(FILE *p)
{
    char computer_name[20];
    int ram,windows;
    p=fopen("computer.txt","r");
    printf("computer name\RAM\tWindows\n");
    while(!feof(p))
    {
        fscanf(p,"%s %d %d\n",computer_name,&ram,&windows);
        printf("%s\t%d\t%d\n",computer_name,ram,windows);
    }
    fclose(p);
}

OUTPUT

Enter the number of computers: 3

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter the Details of computer 1:
ENTER COMPUTER NAME: virus
ENTER THE RAM OF THE COMPUTER: 8
ENTER THE WINDOWS VERSION: 8
+++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter the Details of computer 2:
ENTER COMPUTER NAME: kali
ENTER THE RAM OF THE COMPUTER: 16
ENTER THE WINDOWS VERSION: 3
+++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter the Details of computer 3:
ENTER COMPUTER NAME: parrot
ENTER THE RAM OF THE COMPUTER: 32
ENTER THE WINDOWS VERSION: 6
+++++++++++++++++++++++++++++++++++++++++++++++++
computer nameRAM        Windows
virus   8       8
kali    16      3
parrot  32      6

Process returned 0 (0x0)   execution time : 35.651 s
Press any key to continue.




Write a Modular C Programming code for Operations ( Read & Display ) used in Nodes of Singly linked list | Data Structure.
Read & Display the Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>
struct node
{
 int data;
 struct node *next;
};
struct node *head;
struct node* insert_at_end(struct node *);
void display(struct node *);
struct node *temp,*temp1,*newnode;
main()
{
int ch,p=0,n;
head=NULL;

printf("\nEnter the Number of Nodes you want!: ");
scanf("%d",&n);

             printf("\nEnter the Datails of Nodes:\n");
             while(p!=n)
             {
             newnode=(struct node*)malloc(sizeof(struct node));
             scanf("%d",&newnode->data);
             head=insert_at_end(newnode);
             p++;
             }
printf("\nThe nodes data You have entered are:\n");
display(head);
}
struct node* insert_at_end(struct node *newnode)
{
   if(head==NULL)
   {
     head=newnode;
     head->next=NULL;
     return(head);
   }
   else
   {
     temp=head;
     while(temp->next!=NULL)
     {
        temp=temp->next;

     }
     temp->next=newnode;
        newnode->next=NULL;
        return(head);

   }
}
void display(struct node *head)
{
   if(head==NULL)
   {
     printf("The linked list is empty\n");
   }
   else
   {
      temp=head;
      while(temp!=NULL)
      {
         printf("%d->",temp->data);
         temp=temp->next;
      }
      printf("\n");
   }
}

OUTPUT

Enter the Number of Nodes you want!: 5

Enter the Datails of Nodes:
6
3
2
1
3

The nodes data You have entered are:
6->3->2->1->3->

Process returned 0 (0x0)   execution time : 7.569 s
Press any key to continue.











Write a Modular C Programming code for All Operations ( inserting at the beginning & End | deleting from beginning & end | Display & exit) used in Nodes of Singly linked list | Data Structure.
The Programme should be like a Menu card:(using case numbers)  The code should do the operation which is given by the user.

Read & Delete the Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>
struct node
{
 int data;
 struct node *next;
};
struct node *head;
struct node* insert_at_beg(struct node *);
struct node* insert_at_end(struct node *);
struct node* delete_at_beg(struct node *);
struct node* delete_at_end(struct node *);
void display(struct node *);
struct node *temp,*temp1,*newnode;
main()
{
int ch;
head=NULL;


   while(1)
   {
     printf("\n+++++++++++++++++++++++++++++++++++++++++++++\n");
     printf("1) insert at beginning\n");
     printf("2) insert at the end\n");
     printf("3) delete from beginning\n");
     printf("4) delete from the end\n");
     printf("5) display linked list\n");
     printf("6) exit\n");
     printf("+++++++++++++++++++++++++++++++++++++++++++++");

     printf("\n\n-> Enter your choice: ");
     scanf("%d",&ch);
     switch(ch)
     {
      case 1:newnode=(struct node*)malloc(sizeof(struct node));
             printf("Enter data: ");
             scanf("%d",&newnode->data);
             head=insert_at_beg(newnode);
             break;
    case 2: newnode=(struct node*)malloc(sizeof(struct node));
             printf("Enter data: ");
             scanf("%d",&newnode->data);
             head=insert_at_end(newnode);
             break;
    case 3: if(head==NULL)
             printf("The linked list is empty---cant delete\n");
             else
             {
                head=delete_at_beg(head);
             }
             break;
    case 4: if(head==NULL)
             printf("The linked list is empty---cant delete\n");
             else
             {
                head=delete_at_end(head);
             }
             break;
    case 5: display(head);break;
    case 6: exit(0);break;
    default: printf("Invalid choice\n");
     }
   }
}

struct node* insert_at_beg(struct node *newnode)
{
   if(head==NULL)
   {
     head=newnode;
     head->next=NULL;
     return(head);
   }
   else
   {
     newnode->next=head;
     head=newnode;
     return(head);
   }
}


struct node* insert_at_end(struct node *newnode)
{
   if(head==NULL)
   {
     head=newnode;
     head->next=NULL;
     return(head);
   }
   else
   {
     temp=head;
     while(temp->next!=NULL)
     {
        temp=temp->next;

     }
     temp->next=newnode;
        newnode->next=NULL;
        return(head);

   }
}

void display(struct node *head)
{
   if(head==NULL)
   {
     printf("The linked list is empty\n");
   }
   else
   {
      temp=head;
      while(temp!=NULL)
      {
         printf("%d->",temp->data);
         temp=temp->next;
      }
      printf("\n");
   }
}

struct node* delete_at_beg(struct node *head)
{
    if(head==NULL)
    {
        printf("linkded list is empty\n");
    }
    else
    {
       if(head->next==NULL)
       {
           printf("node deleted=%d\n",head->data);
           free(head);
           head=NULL;
           return(head);
       }
       else
       {
           temp=head;
           head=head->next;
           printf("node deleted=%d\n",temp->data);
           free(temp);
           return(head);

       }
    }

}


struct node* delete_at_end(struct node *head)
{
    if(head==NULL)
    {
        printf("linkded list is empty\n");
    }
    else
    {
       if(head->next==NULL)
       {
           printf("node deleted=%d\n",head->data);
           free(head);
           head=NULL;
           return(head);
       }
       else
       {
           temp=head;
           while(temp->next!=NULL)
           {
               temp1=temp;
               temp=temp->next;
           }
           printf("node deleted=%d\n",temp->data);
           free(temp);
           temp1->next=NULL;
           return(head);

       }
    }

}

OUTPUT

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 3
the linked list is empty---cant delete

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 1
Enter data: 10

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 2
Enter data: 20

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 5
10->20->

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 3
node deleted=10

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 4
node deleted=20

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 6

Process returned 0 (0x0)   execution time : 51.699 s
Press any key to continue.




Write a Modular C Programming code for All Operations Student Details -> Name, R.no, Marks ( inserting at the beginning & End | deleting from beginning & end | Display & exit) used in Nodes of Singly linked list | Data Structure.
The Program should be like a Menu card:(using case numbers)  The code should perform the operation which is given by the user.

Read & Delete the Student Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>
struct student
{
 char name[30];
 int rno;
 float marks;
 struct student *next;
};
struct student *head;
struct student* insert_at_beg(struct student *);
struct student* insert_at_end(struct student *);
struct student* delete_at_beg(struct student *);
struct student* delete_at_end(struct student *);
void display(struct student *);
struct student *temp,*temp1,*newstudent;
main()
{
int ch;
head=NULL;


   while(1)
   {
     printf("\n+++++++++++++++++++++++++++++++++++++++++++++\n");
     printf("1) insert at the begining\n");
     printf("2) insert at the end\n");
     printf("3) delete from begining\n");
     printf("4) delete from the end\n");
     printf("5) display the linked list\n");
     printf("6) exit\n");
     printf("+++++++++++++++++++++++++++++++++++++++++++++\n");

     printf("\n--> Enter your choice: ");
     scanf("%d",&ch);
     switch(ch)
     {
      case 1:newstudent=(struct student*)malloc(sizeof(struct student));
             printf("Enter the Student name roll no and marks\n");
             scanf("%s%d%f",&newstudent->name,&newstudent->rno,&newstudent->marks);
             head=insert_at_beg(newstudent);
             break;
    case 2: newstudent=(struct student*)malloc(sizeof(struct student));
             printf("Enter the Student name roll no and marks\n");
             scanf("%s%d%f",&newstudent->name,&newstudent->rno,&newstudent->marks);
             head=insert_at_end(newstudent);
             break;
    case 3: if(head==NULL)
             printf("NO STUDENT PRESENT---cant delete\n");
             else
             {
                head=delete_at_beg(head);
             }
             break;
    case 4: if(head==NULL)
             printf("NO STUDENT PRESENT---cant delete\n");
             else
             {
                head=delete_at_end(head);
             }
             break;
    case 5: display(head);break;
    case 6: exit(0);break;
    default: printf("Invalid choice\n");
     }
   }
}

struct student* insert_at_beg(struct student *newstudent)
{
   if(head==NULL)
   {
     head=newstudent;
     head->next=NULL;
     return(head);
   }
   else
   {
     newstudent->next=head;
     head=newstudent;
     return(head);
   }
}


struct student* insert_at_end(struct student *newstudent)
{
   if(head==NULL)
   {
     head=newstudent;
     head->next=NULL;
     return(head);
   }
   else
   {
     temp=head;
     while(temp->next!=NULL)
     {
        temp=temp->next;

     }
     temp->next=newstudent;
        newstudent->next=NULL;
        return(head);

   }
}

void display(struct student *head)
{
   if(head==NULL)
   {
     printf("NO STUDENT PRESENT\n");
   }
   else
   {
      temp=head;
      while(temp!=NULL)
      {
         printf("Name=%s\t RNo=%d\t Marks=%f\n",temp->name,temp->rno,temp->marks);
         temp=temp->next;
      }
      printf("\n");
   }
}

struct student* delete_at_beg(struct student *head)
{
    if(head==NULL)
    {
        printf("NO STUDENT PRESENT---cant delete\n\n");
    }
    else
    {
       if(head->next==NULL)
       {
           printf("student deleted==>name=%s\t rno=%d\t marks=%f\n",head->name,head->rno,head->marks);
           free(head);
           head=NULL;
           return(head);
       }
       else
       {
           temp=head;
           head=head->next;
           printf("student deleted==>name=%s\t rno=%d\t marks=%f\n",temp->name,temp->rno,temp->marks);
           free(temp);
           return(head);

       }
    }

}


struct student* delete_at_end(struct student *head)
{
    if(head==NULL)
    {
        printf("NO STUDENT PRESENT---cant delete\n");
    }
    else
    {
       if(head->next==NULL)
       {
            printf("student deleted==>name=%s\t rno=%d\t marks=%f\n",head->name,head->rno,head->marks);
           free(head);
           head=NULL;
           return(head);
       }
       else
       {
           temp=head;

           while(temp->next!=NULL)
           {
               temp1=temp;
               temp=temp->next;
           }
          printf("student deleted==>name=%s\t rno=%d\t marks=%f\n",temp->name,temp->rno,temp->marks);
           free(temp);
           temp1->next=NULL;
           return(head);

       }
    }

}


OUTPUT

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from begining
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 1
Enter the Student name roll no and marks
Jimmy
99
520

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 2
Enter the Student name roll no and marks
MrBeast
100
600

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 5
Name=Jimmy       RNo=99  Marks=520.000000
Name=MrBeast     RNo=100         Marks=600.000000


+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 3
student deleted==>name=Jimmy     rno=99  marks=520.000000

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 4
student deleted==>name=MrBeast   rno=100         marks=600.000000

+++++++++++++++++++++++++++++++++++++++++++++
1) insert at the beginning
2) insert at the end
3) delete from beginning
4) delete from the end
5) display the linked list
6) exit
+++++++++++++++++++++++++++++++++++++++++++++

--> Enter your choice: 6

Process returned 0 (0x0)   execution time : 66.901 s
Press any key to continue.




Write a Modular C Programming code for All Operations ( inserting at selected position | counting & searching | Display & exit) used in Nodes of Singly linked list | Data Structure.
The Programme should be like a Menu card:(using case numbers)  The code should do the operation which is given by the user.

Read & Display the Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>
struct node
{
 int data;
 struct node *next;
};

struct node *head;
struct node* insert_at_end(struct node *);
void display(struct node *);
int count_nodes(struct node *);
struct node * insert_at_pos(struct node *, int);
void search(struct node *, int);
struct node *temp,*temp1,*newnode;
struct node* insert_at_beg(struct node *);
main()
{
int ch,c,pos,n,k,p;
head=NULL;

printf("\nEnter the Number of Nodes you want: ");
scanf("%d",&n);

             printf("\nEnter the Datails of Nodes:\n");
             while(p!=n)
             {
             newnode=(struct node*)malloc(sizeof(struct node));
             scanf("%d",&newnode->data);
             head=insert_at_end(newnode);
             p++;
             }
   while(1)
   {
     printf("\n\n+++++++++++++++++++++++++++++++++++++++++++++\n");
     printf("1) Display linked list\n");
     printf("2) Count no of nodes\n");
     printf("3) Insert a node at a specific position\n");
     printf("4) Search for a given node\n");
     printf("5) Exit\n");
     printf("+++++++++++++++++++++++++++++++++++++++++++++\n");

     printf("\n-> Enter your choice: ");
     scanf("%d",&ch);
     switch(ch)
     {

    case 1: display(head);break;
    case 2: c=count_nodes(head);
                      printf("no of nodes=%d\n",c);break;
    case 3: printf("Enter position: ");
                   scanf("%d",&pos);
                   if(pos<1||pos>count_nodes(head)+1)
                   {
                       printf("Invalid pos\n");
                   }
                   else
                   {
                         newnode=(struct node*)malloc(sizeof(struct node));
                         printf("Enter data: ");
                        scanf("%d",&newnode->data);
                       head=insert_at_pos(newnode,pos);
                   }
                   break;
    case 4: printf("Enter the data you want to search : ");
            scanf("%d",&k);
            search(head,k);
            break;
    case 5: exit(0);break;
    default: printf("Invalid choice\n");
     }
   }
}


struct node* insert_at_end(struct node *newnode)
{
   if(head==NULL)
   {
     head=newnode;
     head->next=NULL;
     return(head);
   }
   else
   {
     temp=head;
     while(temp->next!=NULL)
     {
        temp=temp->next;

     }
     temp->next=newnode;
        newnode->next=NULL;
        return(head);

   }
}

void display(struct node *head)
{
   if(head==NULL)
   {
     printf("The linkded list is empty\n");
   }
   else
   {
      temp=head;
      while(temp!=NULL)
      {
         printf("%d->",temp->data);
         temp=temp->next;
      }
      printf("\n");
   }
}

int count_nodes(struct node *head)
{
    int count=0;
    if(head==NULL)
   return(count);
    else
    {
        temp=head;
        while(temp!=NULL)
        {
            count++;
            temp=temp->next;
        }
        return(count);
    }
}

struct node* insert_at_beg(struct node *newnode)
{
   if(head==NULL)
   {
     head=newnode;
     head->next=NULL;
     return(head);
   }
   else
   {
     newnode->next=head;
     head=newnode;
     return(head);
   }
}


struct node* insert_at_pos(struct node* newnode, int pos)
{
    int p=1;
    if(pos==1)
        head=insert_at_beg(newnode);
    else
    {
        temp=head;
        while(p!=pos)
        {
            temp1=temp;
            temp=temp->next;
            p++;
        }
        temp1->next=newnode;
        newnode->next=temp;
    }
    return(head);
}

void search(struct node* head, int k)
{
    int i,fu;
    fu=count_nodes(head);
    temp=head;



        for(i=1;i<=fu;i++) { if(k==temp->data)
        {
            printf("\nThe data is found!!!");
            printf("\nThe position of data is: %d",i);
            return(0);
        }
        temp=temp->next;

    }
    printf("\nThe Entered Data is not Found!!!");

}

Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

OUTPUT

Enter the Number of Nodes you want: 5

Enter the Datails of Nodes:
10
20
30
40
50


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 1
10->20->30->40->50->


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 2
no of nodes=5


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 3
Enter position: 2
Enter data: 60


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 1
10->60->20->30->40->50->


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 2
no of nodes=6


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 4
Enter the data you want to search : 70

The Entered Data is not Found!!!

+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 20
Invalid choice


+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 4
Enter the data you want to search : 20

The data is found!!!
The position of data is: 3

+++++++++++++++++++++++++++++++++++++++++++++
1) Display linked list
2) Count no of nodes
3) Insert a node at a specific position
4) Search for a given node
5) Exit
+++++++++++++++++++++++++++++++++++++++++++++

-> Enter your choice: 5

Process returned 0 (0x0)   execution time : 48.558 s
Press any key to continue.








Write a Modular C Programming code for Circular Linked Lists All Operations ( Inserting & Deleting in Begining and end | counting & searching |Sorting & arranging nodes | Display & exit) | Data Structure.
The Programme should be like a Menu card:(using case numbers)  The code should do the operation which is given by the user.

Read & Display the Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>
struct node
{
  int data;
  struct node *next;
};
struct node *head,*temp,*temp1,*newnode;
struct node * insert_at_beg(struct node *);
struct node * insert_at_end(struct node *);
struct node * delete_at_beg(struct node *);
struct node * delete_at_end(struct node *);
int count_nodes(struct node*);
struct node* sort(struct node*);
void display(struct node *);


main()
{
  head=NULL;
  int ch,c;
  while(1)
  {
printf("\n+++++++++++++++++++++++++++++++++++++++++++++\n\n");
  printf("1) insert at begining\n");
  printf("2) insert at end\n");
  printf("3) delete at begining\n");
  printf("4) delete at end\n");
  printf("5) display\n");
  printf("6) count nodes\n");
     printf("7) sort nodes\n");
     printf("8) exit\n");
     printf("\n+++++++++++++++++++++++++++++++++++++++++++++\n");

  printf("\n-> Enter the choice: ");
scanf("%d",&ch);
switch(ch)
{
  case 1: newnode=(struct node *)malloc(sizeof(struct node));
                 printf("\nEnter the data: ");
                 scanf("%d",&newnode->data);
                 head=insert_at_beg(newnode);
                 break;
  case 2: newnode=(struct node *)malloc(sizeof(struct node));
                 printf("\nEnter the data:");
                 scanf("%d",&newnode->data);
                 head=insert_at_end(newnode);
                 break;
case 3: head=delete_at_beg(head);
               break;
case 4:head=delete_at_end(head);
               break;
case 5: display(head);
              break;
case 6: c=count_nodes(head);
                            printf("\nNo of nodes=%d\n",c);
                            break;
case 7: head=sort(head);
        printf("\nThe Sorted List is:\n");
        display(head);
                             break;
            case 8: exit(0);break;
default:printf("\nInvalid choice\n");break;
}
}
}


struct node * insert_at_beg(struct node *newnode)
{
   if(head==NULL)
     {
        head=newnode;
        newnode->next=head;
     }
     else
     {
        temp=head;
        while(temp->next!=head)
        {
           temp=temp->next;
        }
        temp->next=newnode;
        newnode->next=head;
        head=newnode;
     }
     return(head);
}


struct node * insert_at_end(struct node *newnode)
{
   if(head==NULL)
     {
        head=newnode;
        newnode->next=head;
     }
     else
     {
        temp=head;
        while(temp->next!=head)
        {
           temp=temp->next;
        }
        temp->next=newnode;
        newnode->next=head;
     }
     return(head);
}



struct node * delete_at_beg(struct node *head)
{
   if(head==NULL)
     {
        printf("CLL is empty--cant delete\n");
     }
     else
     {
         if(head->next==head)
         {
            printf("node deleted=%d\n",head->data);
            free(head);
            head=NULL;
         }
         else
         {
             temp=head;
             while(temp->next!=head)
             {
               temp=temp->next;
             }
              printf("node deleted=%d\n",head->data);
              temp1=head->next;
              free(head);
              temp->next=temp1;
              head=temp1;
         }
     }
     return(head);
}



struct node * delete_at_end(struct node *head)
{
   if(head==NULL)
     {
        printf("CLL is empty--cant delete\n");
     }
     else
     {
         if(head->next==head)
         {
            printf("node deleted=%d\n",head->data);
            free(head);
            head=NULL;
         }
         else
         {
             temp=head;
             while(temp->next!=head)
             {
             temp1=temp;
               temp=temp->next;
             }
              printf("node deleted=%d\n",temp->data);
             free(temp);
             temp1->next=head;
         }
     }
     return(head);
}



void display(struct node *head)
{
  if(head==NULL)
     {
        printf("CLL is empty\n");
     }
     else
     {
         temp=head;
         while(temp->next!=head)
         {
            printf("%d->",temp->data);
            temp=temp->next;
         }
         printf("%d->\n",temp->data);
     }
}

int count_nodes(struct node *head)
{
    int c=0;
    if(head==NULL)
   return(c);
    else
    {
        temp=head;
        while(temp->next!=head)
        {
            c++;
            temp=temp->next;
        }
        return(c+1);
    }
}

struct node* sort(struct node* head)
{
    int c,i,j;
  if(head==NULL)
    printf("CLL is empty--cant sort\n");
  else
  {
      if(head->next==head)
        return(head);
      else
      {
          temp1=(struct node*)malloc(sizeof(struct node));
          c=count_nodes(head);
          for(i=1;i<c;i++)
          {
               temp=head;
                for(j=1;j<=c-i;j++) { if(temp->data > temp->next->data)
                    {
                        temp1->data=temp->data;
                        temp->data=temp->next->data;
                        temp->next->data=temp1->data;
                    }
                    temp=temp->next;
                }
          }
      }
  }
  return(head);
}


OUTPUT

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 1

Enter the data: 10

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 1

Enter the data: 60

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 1

Enter the data: 40

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 2

Enter the data:50

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 2

Enter the data:80

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 5
40->60->10->50->80->

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 6

No of nodes=5

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 7

The Sorted List is:
10->40->50->60->80->

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 5
10->40->50->60->80->

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 9

Invalid choice

+++++++++++++++++++++++++++++++++++++++++++++

1) insert at begining
2) insert at end
3) delete at begining
4) delete at end
5) display
6) count nodes
7) sort nodes
8) exit

+++++++++++++++++++++++++++++++++++++++++++++

-> Enter the choice: 8

Process returned 0 (0x0)   execution time : 34.192 s
Press any key to continue.







Doubly linked lists – All Operation (Insert, count, display, Search)
by factsprime
Write a Modular C Programming code for All Operations ( inserting at selected position | counting & searching | Display & exit) used in Nodes of Doubly linked list | Data Structure.
The Programme should be like a Menu card:(using case numbers)  The code should do the operation which is given by the user.

Read & Display the Data given to the node. 

Refer to Notes: Notes on Data Structures And Algorithms – Linked List

CODE:

#include<stdio.h>
#include<stdlib.h>

struct node
{
    int data;
    struct node *rl;
    struct node *ll;
};
struct node * create_node();
struct node * insert_end(struct node * head);
struct node * insert_front(struct node * head);
struct node * delete_end(struct node * head);
struct node * delete_front(struct node * head);
struct node * search_delete(struct node * head);
void display(struct node * head);
struct node *cur;
void display_ulta(struct node * head);
int count_a(struct node * head);
void search(struct node * head);

int main()
{
    int ch,count=0;
    struct node *head=NULL;
    while(1)
    {
        printf("\n1.INSERT END\n2.DELETE END\n3.DISPLAY\n4.DISPLAY ulta\n5.COUNT\n6.SEARCH\n7.INSERT FRONT\n8.DELETE FRONT\n9.SEARCH TO DELETE\n10.EXIT\n");
        printf("Enter ur choice\n");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1:head=insert_end(head);
            break;
            case 2:head=delete_end(head);
            break;
            case 3:display(head);
            break;
            case 4:display_ulta(head);
            break;
            case 5:count=count_a(head);
            printf("No of list are: %d",count);
            break;
            case 6:search(head);
            break;
            case 10:exit(0);
            break;
            case 9:head=search_delete(head);
            break;
            case 7:head=insert_front(head);
            break;
            case 8:head=delete_front(head);
            break;
            default:printf("Enter valid choice");
        }

    }
}

struct node * create_node()
{
   struct node *newnode;
   newnode=(struct node *)malloc(sizeof(struct node));
   if(newnode==NULL)
   {
       printf("NO memory allocated");
   }
   printf("Enter data\n");
   scanf("%d",&newnode->data);
   newnode->rl=NULL;
   newnode->ll=NULL;
   return newnode;
}
struct node * insert_end(struct node * head)
{
    struct node * newnode;
    newnode=create_node();
    if(head==NULL)
    {
        head=newnode;
    }
    else
    {
        cur=head;
        while(cur->rl!=NULL)
        {
            cur=cur->rl;
        }
        newnode->ll=cur;
        cur->rl=newnode;
    }
    return head;
}

struct node * insert_front(struct node * head)
{
    struct node * newnode=create_node();
    if(head==NULL)
    {
        head=newnode;
    }
    else
    {
        newnode->rl=head;
        head->ll=newnode;
        head=newnode;
    }
    return head;
}

struct node * delete_end(struct node * head)
{
   struct node * prev;
   if(head==NULL)
   {
       printf("LIST EMPTY\n");
   }
   else if(head->rl==NULL)
   {
       printf("deleted %d",head->data);
       free(head);
       head=NULL;
   }
   else
    {
        cur=head;
        while(cur->rl!=NULL)
        {
            cur=cur->rl;
        }
        prev=cur->ll;
        prev->rl=NULL;
        printf("deleted %d",cur->data);
        free(cur);
    }
    return head;
}

struct node * delete_front(struct node * head)
{
    struct node * temp;
    if(head==NULL)
    {
        printf("LIST EMPTY\n");
    }
    else
    {
        temp=head;
        head=head->rl;
        printf("deleted %d",temp->data);
        head->ll=NULL;
        free(temp);
    }
    return head;
}
void display(struct node * head)
{
    if(head==NULL)
    {
        printf("LIST EMPTY\n");
    }
    else
    {
        cur=head;
        while(cur!=NULL)
        {
            printf("%d->",cur->data);
            cur=cur->rl;
        }
    }
}

int count_a(struct node * head)
{
    int count=0;
    if(head==NULL)
    {
        printf("LIST EMPTY\n");
    }
    else
    {
        cur=head;
        while(cur!=NULL)
        {
            count++;
            cur=cur->rl;
        }
    }
    return count;
}

void display_ulta(struct node * head)
{
    if(head==NULL)
    {
        printf("LIST EMPTY\n");
    }
    else
    {
        cur=head;
        while(cur->rl!=NULL)
        {
            cur=cur->rl;
        }
        while(cur!=NULL)
        {
            printf("%d->",cur->data);
            cur=cur->ll;
        }
    }
}

void search(struct node * head)
{
    int key,status=0;
    printf("Enter the data to be searched\n");
    scanf("%d",&key);
    if(head==NULL)
    {
        printf("LIST EMPTY\n");
    }
    else
    {
        cur=head;
        while(cur!=NULL)
        {
            if(key==cur->data)
            {
                status=1;
                break;
            }
            cur=cur->rl;
        }
        if(status==0)
        {
            printf("SEARCH unsucessfull\n");
        }
        else if(status==1)
        {
            printf("SEARCH sucessfull\n");
        }
    }
}

struct node * search_delete(struct node * head)
{
    int key,status=0;
    struct node * temp;
    struct node * prev=NULL;
    printf("Enter the data to be deleted\n");
    scanf("%d",&key);
    if(head==NULL)
    {
        printf("NO DATA TO BE DELETED\n");
    }
    else if(head->data==key)
    {
        head=delete_front(head);
    }
    else
    {
        cur=head;
        while(cur!=NULL)
        {
            if(cur->data==key)
            {
                status=1;
                break;
            }
            prev=cur;
            cur=cur->rl;
        }
        if(status==1)
        {
            prev->rl=cur->rl;
            printf("Deleted %d",key);
            free(cur);
        }
    }
    return head;
}


Also Refer: C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

OUTPUT

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
1
Enter data
36

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
1
Enter data
99

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
1
Enter data
56

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
1
Enter data
695

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
9
Enter the data to be deleted
23

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
3
36->99->56->695->
1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
4
695->56->99->36->
1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
5
No of list are: 4
1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
7
Enter data
100

1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
3
100->36->99->56->695->
1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
5
No of list are: 5
1.INSERT END
2.DELETE END
3.DISPLAY
4.DISPLAY ulta
5.COUNT
6.SEARCH
7.INSERT FRONT
8.DELETE FRONT
9.SEARCH TO DELETE
10.EXIT
Enter ur choice
10

Process returned 0 (0x0)   execution time : 835.979 s
Press any key to continue.






STACKS OPERATIONS

 
CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SIZE 100
struct stack
{
    int data[SIZE];
    int top;
};
void push(struct stack *sptr, int num);
void pop(struct stack *sptr);
void display(struct stack *sptr);
void peek(struct stack *sptr);
int main()

{
    struct stack * sptr;
    struct stack s;
    sptr=&s;
    sptr->top=-1;
    int num,ch;
    while(1)
    {
        scanf("%d",&ch);
        switch(ch)
        {
            case 1:
            scanf("%d",&num);
            push(sptr,num);
            break;
            case 2:pop(sptr);
            break;
            case 3:peek(sptr);
            printf("\n");
            break;
            case -1:exit(0);
            break;
            default:printf("Enter valid choice\n");
            break;
        }
    }
    return 0;
}
void push(struct stack *sptr, int num)
{
    if(sptr->top==SIZE-1)
    {
        printf("stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->data[sptr->top]=num;
    }
}
void pop(struct stack *sptr)
{
    int num;
    if(sptr->top==-1)
    {
        printf("stack underflow\n");
    }
    else
    {
        num=sptr->data[sptr->top];
        sptr->top--;
        printf("%d \n",num);
    }
    
}

void peek(struct stack *sptr)
{
    if(sptr->top==-1)
    {
        printf("Stack empty\n");
    }
    else
    {
        printf("%d",sptr->data[sptr->top]);
    }
}


OUTPUT

Congratulations, you passed the sample test case.
Click the Submit Code button to run your code against all the test cases.

Input (stdin)

1 10
1 20
1 30
2
3
2
1 40
3
-1
Your Output (stdout)

30 
20
20 
40
Expected Output

30
20
20
40









(HackerRank) Write a Modular C Programming code to solve STACKS – DENOMINATIONS, Frankinson has N number of coins in his pocket. Coins are of denominations of 1, 2, 5 and 10.
Frankinson has N number of coins in his pocket. Coins are of denominations of 1, 2, 5 and 10.

He keeps all the coins on the table one above the other. Then he picks out one coin at a time and counts them of specific denomination.

Help Frankinson to count the coins of all the different denominations.

Input Format

First line is N number of coins.

Second line is coins of different denominations.

Constraints

Denomination of each coin should be either 1,2,5 or 10.

Output Format

Number of Coins of Each denomination in separate line.

Sample Input 0

5
1 2 5 10 1
Sample Output 0

Coins of 1 re = 2
Coins of 2 rs = 1
Coins of 5 rs = 1
Coins of 10 rs = 1
Coins of invalid denominations = 0
Sample Input 1

2
1 3
Sample Output 1

Coins of 1 re = 1
Coins of 2 rs = 0
Coins of 5 rs = 0
Coins of 10 rs = 0
Coins of invalid denominations = 1
Sample Input 2

-5
Sample Output 2

Invalid number of coins
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SIZE 100 
struct stack
{
    int coin[SIZE];
    int top;
};
void push(struct stack *sptr, int num);
void pop_count_display(struct stack *sptr);
int main()
{
    struct stack * sptr;
    struct stack s;
    sptr=&s;
    sptr->top=-1;
    int c,n,i;
    scanf("%d",&n);
    if(n<0)
    {
        printf("Invalid number of coins");
        exit(0);
    }
    for(i=0;i<n;i++) 
{ 
scanf("%d",&c); 
push(sptr,c); 
} 
pop_count_display(sptr);
 } 
void push(struct stack *sptr, int num)
 { 
if(sptr->top==SIZE-1)
    {
        printf("Stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->coin[sptr->top]=num;
    }
}
void pop_count_display(struct stack *sptr)
{
        int i,c1=0,c2=0,c5=0,c10=0,c=0;
        for(i=sptr->top;i>=0;i--)
        {
            if(sptr->coin[i]==1)
            {
               c1++;
            }

            else if(sptr->coin[i]==2)
            {
               c2++;
            }
            else if(sptr->coin[i]==5)
            {
               c5++;
            }
            else if(sptr->coin[i]==10)
            {
               c10++;
            }
            else
            {
                c++;
            }
            sptr->top--;
        }
        printf("Coins of 1 re = %d\n",c1);
        printf("Coins of 2 rs = %d\n",c2);
        printf("Coins of 5 rs = %d\n",c5);
        printf("Coins of 10 rs = %d\n",c10);
    printf("Coins of invalid denominations = %d",c);
}

OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

5
1 2 5 10 1
Your Output (stdout)

Coins of 1 re = 2
Coins of 2 rs = 1
Coins of 5 rs = 1
Coins of 10 rs = 1
Coins of invalid denominations = 0
Expected Output

Coins of 1 re = 2
Coins of 2 rs = 1
Coins of 5 rs = 1
Coins of 10 rs = 1
Coins of invalid denominations = 0




(HackerRank) Write a Modular C Programming code to solve Palindrome Stack Integer, Micky is very fond of stacks data structure. He started experimenting the usage of stack for different purposes.
Micky is very fond of stacks data structure. He started experimenting the usage of stack for different purposes. He knew how to reverse an integer number while learning C programming. Now, the same task he wants to achieve using Stacks.

Help Micky to perform reversing and also to check whether an integer number is a palindrome.

Input Format

first line reads the integer.

Constraints

1< Integer <=1000000

Output Format

Print the Number is palindrome or not.

Sample Input 0

121
Sample Output 0

121 is a palindrome number
Sample Input 1

3334
Sample Output 1

3334 is not a palindrome number
Sample Input 2

-55
Sample Output 2

Invalid number 
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SIZE 100

struct stack
{
    int data[SIZE];
    int top;
};
void push(struct stack *sptr, int num);
void check(struct stack *sptr,int no);
int pop(struct stack *sptr);

void push(struct stack *sptr, int num)
{
    if(sptr->top==SIZE-1)
    {
        printf("Stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->data[sptr->top]=num;
    }
}
int pop(struct stack *sptr)
{
    int num;
    num=sptr->data[sptr->top];
    sptr->top--;
    return num;
}

void check(struct stack *sptr,int no)
{
    int temp,num=no,copy,c=0,stat=1;
    while(no!=0)
    {
        temp=no%10;
        push(sptr,temp);
        c++;
        no=no/10;
    }
    copy=num;
    while(copy!=0)
    {
        temp=copy%10;
        if(temp!=pop(sptr))
        {
            stat=0;
            break;
        }
        copy=copy/10;
    }
    if(stat==1)
    {
        printf("%d is a palindrome number",num);
    }
    else
    {
        printf("%d is not a palindrome number",num);
    }
    
    
}
int main()
{
    struct stack * sptr;
    struct stack s;
    int no;
    sptr=&s;
    sptr->top=-1;
    scanf("%d",&no);
    if(no>0)
    {
        check(sptr,no);
    }
    else
    {
        printf("Invalid number ");
        exit(0);
    }
    return 0;
}

OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

121
Your Output (stdout)

121 is a palindrome number
Expected Output

121 is a palindrome number





C Programming – HackerRank Solution | Palindrome Stack String |
by factsprime
(HackerRank) Write a Modular C Programming code to solve Palindrome Stack String, Help Micky to perform reversing and also to check whether a string is palindrome.
Micky is very fond of stacks data structure. He started experimenting the usage of stack for different purposes. He knew how to reverse a string while learning C programming. Now, the same task he wants to achieve using Stacks.

Help Micky to perform reversing and also to check whether a string is palindrome.

Input Format

first line reads the string.

Constraints

input data is string only.

Output Format

print the string is palindrome or not.

Sample Input 0

GADAG
Sample Output 0

GADAG is a palindrome string
Sample Input 1

HUBBALLI
Sample Output 1

HUBBALLI is not a palindrome string
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SIZE 100

struct stack
{
    char data[SIZE];
    int top;
};
void push(struct stack *sptr, char num);
void check(struct stack *sptr,char no[SIZE]);
char pop(struct stack *sptr);

void push(struct stack *sptr, char num)
{
    if(sptr->top==SIZE-1)
    {
        printf("Stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->data[sptr->top]=num;
    }
}
char pop(struct stack *sptr)
{
    int num;
    num=sptr->data[sptr->top];
    sptr->top--;
    return num;
}

void check(struct stack *sptr,char no[SIZE])
{
    int ch,stat=1;
    int i=0;
    char temp;
    while(no[i]!='\0')
    {
        ch=no[i];
        push(sptr,ch);
        i++;
    }
    i=0;
    while(no[i]!='\0')
    {
        temp=no[i];
        if(temp!=pop(sptr))
        {
            stat=0;
            break;
        }
        i++;
    }
    if(stat==1)
    {
        printf("%s is a palindrome string",no);
    }
    else
    {
        printf("%s is not a palindrome string",no);
    }
    
    
}
int main()
{
    struct stack * sptr;
    struct stack s;
    char pa[SIZE];
    sptr=&s;
    sptr->top=-1;
    scanf("%s",pa);
    check(sptr,pa);
    return 0;
}

OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

GADAG
Your Output (stdout)

GADAG is a palindrome string
Expected Output

GADAG is a palindrome string





C Programming – HackerRank Solution | INFIX TO POSTFIX CONVERSION |
by factsprime
(HackerRank) Write a Modular C Programming code to solve INFIX TO POSTFIX CONVERSION, Help Swaraj to write an modular c program to based on given algorithm.
Swaraj wants to learn how to make use of stacks data structure to convert the infix expression to postfix expression. He was discussing with his class teacher. The class teacher provided him an agorithm on the conversion process.

Help Swaraj to write a modular c program to based on given algorithm.

The algorithm is as follows:

image

Input Format

Infix expression.

Constraints

Expression may or may not have parantheses.

Output Format

Converted postfix expression.

Sample Input 0

a+b
Sample Output 0

Given Infix Expression: a+b
Postfix Expression: ab+
Sample Input 1

(2+3*5)-1*3
Sample Output 1

Given Infix Expression: (2+3*5)-1*3
Postfix Expression: 235*+13*-
Sample Input 2

a*b+c/d
Sample Output 2

Given Infix Expression: a*b+c/d
Postfix Expression: ab*cd/+
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

#define SIZE 100

struct stack
{
    char data[SIZE];
    int top;
};
void push(struct stack *sptr, char num);
char pop(struct stack *sptr);
void postfix_conv(char infix[SIZE]);
int pre(char ch);
int main() 
{
    char infix[50];
    scanf("%s",infix);
    postfix_conv(infix);
    return 0;
}

void push(struct stack *sptr, char num)
{
    if(sptr->top==SIZE-1)
    {
        printf("Stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->data[sptr->top]=num;
    }
}
char pop(struct stack *sptr)
{
    char num;
    num=sptr->data[sptr->top];
    sptr->top--;
    return num;
}
char peek(struct stack *sptr)
{
    char c;
    c=sptr->data[sptr->top];
    return c;
}
void postfix_conv(char infix[SIZE])
{
    struct stack s, * sptr;
    sptr=&s;
    sptr->top=-1;
    char postfix[SIZE],ch,elem;
    int i=0,k=0;
    push(sptr,'#');
    while(infix[i]!='\0')
    {
        ch=infix[i];
        if(ch=='(')
        {
            push(sptr,ch);
        }
        else if(isalnum(ch))
        {
            postfix[k++]=ch;
        }
        else if(ch==')')
        {
            while(sptr->data[sptr->top]!='(')
            {
                postfix[k++]=pop(sptr);
            }
            elem=pop(sptr);
        }
        else
        {
            while(pre(peek(sptr))>=pre(ch))
            {
                postfix[k++]=pop(sptr);
            }
            push(sptr,ch);
        }
        i++; 
    }
    while(sptr->data[sptr->top]!='#')
    {
        postfix[k++]=pop(sptr);
    }
    postfix[k]='\0';
    printf("Given Infix Expression: %s\nPostfix Expression: %s",infix,postfix);
}

int pre(char ch)
{
    switch(ch)
    {
        case '#':return 0;
            break;
        case '(':return 1;
            break;
        case '+':
        case '-':return 2;
            break;
        case '/':
        case '*':
        case '%':return 3;
            break;
        case '^':return 4;
            break;
    }
    return 0;
}


OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

a+b
Your Output (stdout)

Given Infix Expression: a+b
Postfix Expression: ab+
Expected Output

Given Infix Expression: a+b
Postfix Expression: ab+




C Programming – HackerRank Solution | POSTFIX EXPRESSION EVALUATION |
by factsprime
(HackerRank) Write a Modular C Programming code to solve POSTFIX EXPRESSION EVALUATION, Help Swaraj in developing the modular c program.
Swaraj wants to now learn how to use stacks data structures to evaluate the postfix expressions. He gets the algorithm from his class teacher.

The class teacher provides the following algorithm for him to study and convert it to a working modular c program.

Help Swaraj in developing the modular c program.

image

Input Format

A valid postfix expression.

Constraints

Postfix expression will not have any kind of parentheses.

Output Format

Evaluated postfix expression.

Sample Input 0

59+
Sample Output 0

Given postfix Expression: 59+
Result after Evaluation: 14
Sample Input 1

12+3-4/
Sample Output 1

Given postfix Expression: 12+3-4/
Result after Evaluation: 0
Sample Input 2

55+75-31/*+
Sample Output 2

Given postfix Expression: 55+75-31/*+
Result after Evaluation: 16
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SIZE 100
struct stack
{
    int data[SIZE];
    int top;
};
void push(struct stack *sptr, int num);
int pop(struct stack *sptr);
int evaluate(struct stack *sptr,char postfix[SIZE]);
int main()
{
    struct stack * sptr;
    struct stack s;
    char postfix[SIZE];
    sptr=&s;
    sptr->top=-1;
    scanf("%s",postfix);
    printf("Given postfix Expression: %s\n",postfix);
    int res=evaluate(sptr,postfix);
    printf("Result after Evaluation: %d\n",res);
    return 0;
}
void push(struct stack *sptr, int num)
{
    if(sptr->top==SIZE-1)
    {
        printf("Stack Overflow\n");
    }
    else
    {
        sptr->top++;
        sptr->data[sptr->top]=num;
    }
}
int pop(struct stack *sptr)
{
    int num;
    num=sptr->data[sptr->top];
    sptr->top--;
    return num;
}
int evaluate(struct stack *sptr,char postfix[SIZE])
{
    int op1,op2,i=0;
    char ch;
    while(postfix[i]!='\0')
    {
        ch=postfix[i];
        if(isdigit(ch)!=0)
        {
            push(sptr,(ch-'0'));
        }
        else
        {
            op2=pop(sptr);
            op1=pop(sptr);
            switch(ch)
            {
                case '+':push(sptr,op1+op2);
                break;
                case '-':push(sptr,op1-op2);
                break;
                case '*':push(sptr,op1*op2);
                break;
                case '/':push(sptr,op1/op2);
                break;
            }
        }
        i++;
    }
    return pop(sptr);
}

OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

59+
Your Output (stdout)

Given postfix Expression: 59+
Result after Evaluation: 14
Expected Output

Given postfix Expression: 59+
Result after Evaluation: 14



C Programming – HackerRank Solution | Right most set bit |
by factsprime
(HackerRank) Write a Modular C Programming code to solve Right most set bit, Given a non-negative number find the position of the right – most set bit (1)
Given a non-negative number find the position of the right – most set bit (1) in the binary representation of the number.

Input Format

First line contains a non-negative number.

Constraints

N>0 and N<= (2^31-1)

Output Format

Display the bit number, where the right most set bit is found in a single line.

Sample Input 0

8
Sample Output 0

3
Explanation 0

8 in binary representation is 1000. We clearly see that the set bit from RHS is at position 3. (right most bit is at position 0.)

3 2 1 0 -----> Bit position
1 0 0 0 -----> The bits 
Sample Input 1

-9
Sample Output 1

Invalid
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

int main() {
    int n,b;
    scanf("%d",&n);
    if(n>0)
    {
        int i=0;
        while(n!=0)
        {
           b=(n%2)*pow(10,i); 
            if(n%2==1)
                break;
            n=n/2;
            i++;
        }
        printf("%d",i);
    }
    else{
        printf("Invalid");
    }
    return 0;
}

OUTPUT

Congratulations, you passed the sample test case.

Click the Submit Code button to run your code against all the test cases.

Input (stdin)

8
Your Output (stdout)

3
Expected Output

3








C Programming – HackerRank Solution | Candy Wending Machine |
by factsprime
(HackerRank) Write a Modular C Programming code to solve QUEUES – Candy Wending Machine, The first line contains n, the number of coins to be inserted in machine.
Shrirish is student participating in coding competition held by KPIT company. He is given a problem statement “Candy Wending Machine”. A machine will request the selected coins to be inserted, they are 1re, 5rs, 10rs and 20rs coins only. When the value of a coin inserted is other than mentioned coins, those coins are returned by the machine.

If the sum of all coins is greater than or equal to 25rs but less than 34rs then fetch Mango Candy from machine, if the sum of all the coins is greater than or equal to 35rs but less than 49rs then fetch Strawberry Candy, if the sum of all the coins is greater than or equal to 50rs but less than 70rs fetch Pista Candy, otherwise display No candy.

Input Format

The first line contains n, the number of coins to be inserted in machine.

The second line contains n space-separated coins with given denominations.

Constraints

1<=n<=100

0<=i<=n

Coins must be either 1,5,10,20.

Output Format

Dislay the candy name.

Sample Input 0

4
5 10 5 20
Sample Output 0

Strawberry candy
Explanation 0

Sum off all coins will be 40, therefore Strawberry candy will be fetched from machine.

Sample Input 1

3
2 5 10
Sample Output 1

No candy
Explanation 1

Denomination 2 is returned by machine. Sum off coins will be 15, therefore No candy.

Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SI 100
struct queue
{
    int data[SI],front,rear;
};
void enqueue(struct queue *qptr,int num)
{
    if(qptr->rear==SI-1)
    {
        printf("Queue Overflow\n");
    }
    else
    {
        qptr->rear++;
        qptr->data[qptr->rear]=num;
    }
}
int dequeue(struct queue *qptr)
{
    int num=0;
    if(qptr->front==qptr->rear)
    {
        return num;
    }
    else
    {
        qptr->front++;
        num=qptr->data[qptr->front];
        return num;
    }
}
void check(int sum)
{
    if(sum>=25&&sum<34) { printf("Mango candy"); } else if(sum>=35&&sum<49) { printf("Strawberry candy"); } else if(sum>=50&&sum<70) { printf("Pista candy"); } else { printf("No candy"); } } int main() { struct queue * qptr; struct queue q; qptr=&q; qptr->front=qptr->rear=-1;
    int num,n,i,sum=0,c;
    scanf("%d",&n);
    for(i=0;i<n;i++) { scanf("%d",&num); enqueue(qptr,num); } while(qptr->rear!=qptr->front)
    {
        c=dequeue(qptr);
        switch(c)
        {
            case 1:sum=sum+1;
                break;
            case 5:sum=sum+5;
                break;
            case 10:sum=sum+10;
                break;
            case 20:sum=sum+20;
                break;    
        }
    }
    check(sum);
    return 0;
}
OUTPUT

Congratulations, you passed the sample test case.
Click the Submit Code button to run your code against all the test cases.

Input (stdin)

4
5 10 5 20
Your Output (stdout)

Strawberry candy
Expected Output

Strawberry candy





C Programming – HackerRank Solution | Indian Sports Academy |
by factsprime
(HackerRank) Write a Modular C Programming code to solve QUEUES – Indian Sports Academy, Number of candidates not selected for Olympics 2022.
Indian Sports Academy conducting selection trials for young candidates who are willing to participate in Olympics 2022. Any candidate between the age group 18 to 35 can participate in the selection process. Indian Sports Academy shortlists based on the height of candidates to be selected for next rounds and only one candidate is selected from each round. Candidates are allowed to enter on first come first serve basis, but only the candidates with a height greater than 185 centimetres will be selected for next round. Given the heights of candidates determine how may candidates are not selected for Olympics 2022.

Input Format

First Line indicates number of candidates N.

Second Line indicates height of candidates. (integer values seperated by a space)

Constraints

0 < N <= 100

Height of candidates is integer values.

Output Format

Number of candidates not selected for Olympics 2022.

Sample Input 0

7
213 200 160 225 185 195 175
Sample Output 0

3
Sample Input 1

2
210 190
Sample Output 1

0
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SI 100
struct queue
{
    int data[SI],front,rear;
};
void enqueue(struct queue *qptr,int num)
{
    if(qptr->rear==SI-1)
    {
        printf("Queue Overflow\n");
    }
    else
    {
        qptr->rear++;
        qptr->data[qptr->rear]=num;
    }
}
int dequeue(struct queue *qptr)
{
    int num=0;
    if(qptr->front==qptr->rear)
    {
        return num;
    }
    else
    {
        qptr->front++;
        num=qptr->data[qptr->front];
        return num;
    }
}

int main() 
{
    struct queue * qptr;
    struct queue q;
    qptr=&q;
    qptr->front=qptr->rear=-1;
    int num,n,i,sum=0,c,count=0;
    scanf("%d",&n);
    for(i=0;i<n;i++) { 
scanf("%d",&num); 
enqueue(qptr,num); }
 while(qptr->rear!=qptr->front)
    {
        c=dequeue(qptr);
        if(c<=185)
        {
            count++;
        }
    }
    printf("%d",count);
    return 0;
}
OUTPUT

Congratulations, you passed the sample test case.
Click the Submit Code button to run your code against all the test cases.

Input (stdin)

7
213 200 160 225 185 195 175
Your Output (stdout)

3
Expected Output

3



C Programming – HackerRank Solution | Traffic Signals |
by factsprime
(HackerRank) Write a Modular C Programming code to solve QUEUES – Traffic Signals, The experiment ends when either Ptolem or Neil or both stacks are empty.
Trump has been stuck in traffic in the streets of Mexico due to the malfunctioning of the traffic signal. Trump has a professional hacker with him travelling. Hacker can get into the traffic system and change the colour of the lights. In his country, Trump had different traffic rule such that there are N bulbs on the traffic board and only when all of them are green (G) the cars can pass. there are 2 other colours which the bulbs show: i.e. Red (R) & Yellow (Y). Note that the lights are designed such that they follow the colour change in cyclic pattern as follows:

Y—–>G—–>R—–>Y

Trump ordered his co-passenger, Hacker, to get into the system, he can select any position of light and update start updating the lights by increasing their colour by 1 next colour of lights as given in above sequence. This whole process takes 1 second for changing one light and he can repeat this process any number of times until he gets all the lights Green. Find the minimum time to do the process as Trump was getting late for Video Conference with Narendra.

Explanation: Consider 3 lights on a Signal: R Y G.

During first check, R updates to Y, next colour Y updates to G, and last colour does not update. Colour changes = 2.

Now lights on the signal are: Y G G.

During the second check, Y updates to G. Next colour G does not update. Similarly for the 3rd light in the signal, does not update. Therefore Colour changes = 1. Now lights on signal are: G G G.

No further updates in the colour of the lights on the signal.

Therefore minimum colour changes = 3.

Input Format

First Line N indicates number of lights on the signal.

Second Line indicates colours of N lights. single character, seperated by space.

Constraints

N value is integer between 0 to 100.

Color of each light is single character ( R, G or Y).

Output Format

Minimum colour changes to make all lights Green (G).

Sample Input 0

4
R Y G R
Sample Output 0

5
Sample Input 1

6
R R R R R R
Sample Output 1

12
Refer : C Programming HackerRank all solutions for Loops | Arrays | strings | Data Structures | Linked lists | Stacks | Queues | Binary Trees

 

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define SI 10
struct queue
{
    char data[SI];
    int front,rear;
};
void enqueue(struct queue *qptr,char num)
{
    if(qptr->rear==-1&&qptr->front==-1)
    {
        qptr->front=qptr->rear=0;
        qptr->data[qptr->rear]=num;
    }
    else if((qptr->rear+1)%SI==qptr->front)
    {
        printf("Queue Overflow\n");
    }
    else
    {
        qptr->rear=(qptr->rear+1)%SI;
        qptr->data[qptr->rear]=num;
    }
}
int dequeue(struct queue *qptr)
{
    char num='0';
    if(qptr->front==-1&&qptr->rear==-1)
    {
        return num;
    }
    else if(qptr->front==qptr->rear)
    {
        num=qptr->data[qptr->front];
        qptr->front=qptr->rear=-1;
    }
    else
    {
        num=qptr->data[qptr->front];
        qptr->front=(qptr->front+1)%SI;
    }
    return num;
}
void check(struct queue *qptr)
{
    char c1;
    int count=0;
    while(qptr->front!=qptr->rear||(qptr->rear==0&&qptr->front==0))
    {
        c1=dequeue(qptr);
        if(c1=='R')
        {
            enqueue(qptr,'Y');
            count++;
        }
        else if(c1=='Y')
        {
            enqueue(qptr,'G');
            count++;
        } 
    }
    printf("%d",count);
}
int main() 
{
    struct queue * qptr;
    struct queue q;
    qptr=&q;
    qptr->front=qptr->rear=-1;
    int n,ch,i;
    scanf("%d",&n);
    if(n>0&&n<100)
    {
        for(i=0;i<n;i++)
    {
        scanf(" %lc ",&ch);
        enqueue(qptr,ch);
    }
    check(qptr);
    }
    return 0;
}


OUTPUT

Congratulations, you passed the sample test case.
Click the Submit Code button to run your code against all the test cases.

Input (stdin)

4
R Y G R
Your Output (stdout)

5
Expected Output

5







Write a Modular C Programming Code for Password Cheak Strings | Sentence?
Condition: contains at least 8 characters in length, must contain one uppercase, one lowercase, one special character, and one digit.

CODE:

#include<stdio.h>
#include<string.h>
#define MAX 100
int check_password(char password[]);
main()
{
char password[MAX];
while(1)
{
printf("\nEnter the password:\n");
gets(password);
if(check_password(password))
{
printf("Password is valid:\n");
break;
}
else
{
printf("\nPassword must be of atleast 8 characters in length, with one upper-case, one lower-case, one digit and one special character\n");
}
}
}

int check_password(char password[])
{
int i;
int upper_flag = 0;
int lower_flag = 0;
int special_flag = 0;
int digit_flag = 0;
if(strlen(password)<8)
return 0;
else
{
while(password[i]!='\0')
{
if(password[i] >='A' && password[i]<='Z')
upper_flag = 1;
else if(password[i] >='a' && password[i]<='z')
lower_flag = 1;
else if(password[i] >='0' && password[i]<='9')
digit_flag = 1;
else
special_flag =1;
i++; //Next character
}//end while
if(upper_flag == 1 && lower_flag == 1 && digit_flag == 1
&& special_flag == 1)
return 1;
else
return 0;
}//end outer else
}

 
OUTPUT

Enter the password:
cprogramming_is_fun@

Password must be of atleast 8 characters in length, with one upper-case, one lower-case, one digit and one special character

Enter the password:
CPROGRAMMING_IS_FUN@

Password must be of atleast 8 characters in length, with one upper-case, one lower-case, one digit and one special character

Enter the password:
Cprogramming_Is_Fun@

Password must be of atleast 8 characters in length, with one upper-case, one lower-case, one digit and one special character

Enter the password:
Cprogramming_Is_Fun@123
Password is valid:

Process returned 0 (0x0) execution time : 85.157 s
Press any key to continue.



Write a Modular C Programming Code for Reversing the given String | Sentence?
CODE:

#include<stdio.h>
#include<string.h>
void reverse_string(char string[]);
main()
{
char string[100];
printf("Enter the string: ");
gets(string);
reverse_string(string);
printf("\nThe reversed string is :");
puts(string);
}
void reverse_string(char string[])
{
char temp;
int n = strlen(string);
int low_limit = 0;
int high_limit = n-1;
while(low_limit<high_limit)
{
temp = string[low_limit];
string[low_limit]=string[high_limit];
string[high_limit] = temp;
high_limit --;
low_limit ++;
}
}

 
OUTPUT

Enter the string: Experience is the name everyone gives to their mistakes

The reversed string is :sekatsim rieht ot sevig enoyreve eman eht si ecneirepxE

Process returned 0 (0x0) execution time : 3.398 s
Press any key to continue.



Write a Modular C Programming Code for Checking Anagram (same no of characters values) of Strings | Sentence?
CODE:

#include<stdio.h>
#include<string.h>
int isAnagram(char string1[], char string2[]);
#define MAX 200
main()
{
char string1[MAX];
char string2[MAX];
printf("Enter the text written by Seeta:\n");
gets(string1);
printf("Enter the text written by Geeta:\n");
gets(string2);
if(isAnagram(string1,string2))
{
printf("Seeta and Geeta have used same characters same number of time\n");
}
else
{
printf("Seeta and Geeta have not used same characters same number of time\n");
}
}
int isAnagram(char string1[], char string2[])
{

int count1[26]={0};
int count2[26]={0};
int i =0;
int j=0;
char ch;

while(string1[i]!='\0')
{
ch =toupper(string1[i]);
if(ch>='A' && ch<='Z')
{
count1[ch-'A']++;
}
i++;
}

while(string2[j]!='\0')
{
ch =toupper(string2[j]);
if(ch>='A' && ch<='Z')
{
count2[ch-'A']++;
}
j++;
}
for(i=0;i<26;i++)
{
if(count1[i]!=count2[i])
return 0;
}
return 1;
}

OUTPUT

Enter the text written by Seeta:
TOO YUMM!
Enter the text written by Geeta:
oot ummY!
Seeta and Geeta have used same characters same number of time

Process returned 0 (0x0) execution time : 31.355 s
Press any key to continue.



Write a Modular C Programming Code for Deleting Elements from Strings | Sentence?
CODE:

#include<stdio.h>
#include<string.h>
void DELETE(char str[],int position, int length);
main()
{
char str[100];
int position, length;
printf("Enter the string\n");
scanf("%s",str);
printf("From which position the characters of a string should be deleted\n");
scanf("%d",&position);
printf("How many character should be deleted from %d position\n",position);
scanf("%d",&length);
DELETE(str,position,length);
printf("String after deletion of characters = %s\n",str);
}
void DELETE(char str[],int position, int length)
{
int i=0;
int j =0;
char target[100];
while(i<position-1)
{
target[j]=str[i];
i++;
j++;
}
i = i + length;
while(str[i]!='\0')
{
target[j]=str[i];
i++;
j++;
}
target[j]='\0';
strcpy(str,target);
}

 
OUTPUT

Enter the string
123456789
From which position the characters of a string should be deleted
2
How many character should be deleted from 2 position
3
String after deletion of characters = 156789

Process returned 0 (0x0) execution time : 11.548 s
Press any key to continue.


Write a Modular C Programming Code for Sorting Strings | Sentence Ascending and Descending?
CODE:

#include<stdio.h>
#include<string.h>
void sort(char str[]);
main()
{
char str[1000];
printf("Enter the word\n");
scanf("%s",str);
sort(str);
printf("\nWord after sorting each character = %s\n",str);
}
void sort(char str[])
{
int i,j;
char temp;
for(i=0;str[i]!='\0';i++)
{
for(j=0;j<strlen(str)-1-i;j++)
{
if(str[j] > str[j+1])
{
temp = str[j];
str[j] = str[j+1];
str[j+1]=temp;
}
}
}
}

 
OUTPUT

Enter the word
qwertyuiopasdfghjklzxcvbnm

Word after sorting each character = abcdefghijklmnopqrstuvwxyz

Process returned 0 (0x0) execution time : 15.719 s
Press any key to continue.


Write a Modular C Programming code for Getting Books Sorting, Linear Search, palindrome in data Structure
Read the number of students, read their information, and display the details of the students:

CODE:

#include<stdio.h>
struct book
{
    char name[30];
    int isbn;
    int no_of_pages;
    float price;
};
struct book b[1000];
void readStructure(struct book b[1000] ,int n);
void displayStructure(struct book b[1000] ,int n);
void orderBooks(struct book b[1000] ,int n);
void searchBook(struct book b[1000] , int n);
void palindromeISBN(struct book b[1000], int n);
int isPalindrome(int k);
main()
{
    int n;
    int k;
    printf("Enter the number of books: ");
    scanf("%d",&n);
    readStructure(b,n);
    displayStructure(b,n);
    orderBooks(b,n);
    searchBook(b,n);
    palindromeISBN(b,n);
}
void readStructure(struct book b[1000] ,int n)
{
    int i;
    for(i=0;i<n;i++)
    {
        printf("\nEnter Details of Book %d",i+1);
        printf("\nEnter the Name: ");
scanf("%s",&b[i].name);
printf("Enter the IsBn: ");
scanf("%d",&b[i].isbn);
printf("Enter the No of Pages: ");
scanf("%d",&b[i].no_of_pages);
printf("Enter the Price: ");
scanf("%f",&b[i].price);
printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n");
    }
}
void displayStructure(struct book b[1000] ,int n)
{
    int i,k=1;
    printf("Book details\n");
    for(i=0;i<n;i++)
    {
         printf("\nDetails of Book %d",i+1);
        printf("\nName: %s",b[i].name);
printf("\nEnter the IsBn: %d",b[i].isbn);
printf("\nEnter the No of Pages: %d",b[i].no_of_pages);
printf("\nEnter the Price: %f",b[i].price);
printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n");

    }

}
void orderBooks(struct book b[1000] ,int n)
{
    int i,j;
    struct book temp;
    printf("\nAfter arranging the books in ascending order\n");
    for(i=0;i<n-1;i++)
    {
         for(j=0;j<n-i-1;j++)
 { 
if(b[j].isbn>b[j+1].isbn)
            {
                temp=b[j];
                b[j]=b[j+1];
                b[j+1]=temp;
            }
        }
    }
    displayStructure(b,n);
   printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
}
void searchBook(struct book b[1000] , int n)
{
    int i,k,j;
    int flag=1;
    printf("Enter the isbn number of book to search: ");
    scanf("%d",&k);
    printf("Details of Book of required ISBN number is: \n");
    for(i=0;i<n;i++)
    {
            if(b[i].isbn==k)
        {
             printf("Book found\n");
             printf("Name= %s\nISBN= %d\nNumber of pages=%d\nPrice= %f\n",b[i].name,b[i].isbn,b[i].no_of_pages,b[i].price);
             flag=1;
             break;
        }
        else
            flag=0;
    }
    if(flag==0)
        printf("\nBook not found!!!");
        printf("-----------------------------------------------------------------------------------------------------------\n");
}
void palindromeISBN(struct book b[1000], int n)
{
    int i,k;
    printf("\nDetails of books whose ISBN is a palindrome are: \n");
    printf("\n\nName\tISBN\tNumber of pages\tPrice\n");
    for (i=0;i<n;i++)
    {
        k=isPalindrome(b[i].isbn);
        if(k==1)
            printf("%s\t\t%d\t\t%d\t\t%f\n",b[i].name,b[i].isbn,b[i].no_of_pages,b[i].price);
    }
    printf("-------------------------------------------------------------------------------------------");
}
int isPalindrome(int k)
{
    int r,rev=0;
    int temp;
    temp=k;
    while(k)
    {
        r=k%10;
        rev=rev*10+r;
        k=k/10;
    }
    if(temp==rev)
        return 1;
    else
        return 0;
}


OUTPUT

Enter the number of books: 5

Enter Details of Book 1
Enter the Name: DavinciCode
Enter the IsBn: 101
Enter the No of Pages: 500
Enter the Price: 600

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Book 2
Enter the Name: Avathar
Enter the IsBn: 123321
Enter the No of Pages: 600
Enter the Price: 800

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Book 3
Enter the Name: Avanish
Enter the IsBn: 606
Enter the No of Pages: 800
Enter the Price: 500

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Book 4
Enter the Name: Nagas
Enter the IsBn: 909
Enter the No of Pages: 650
Enter the Price: 850

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Book 5
Enter the Name: Papillon
Enter the IsBn: 424
Enter the No of Pages: 1800
Enter the Price: 5000

+++++++++++++++++++++++++++++++++++++++++++++++++
Book details

Details of Book 1
Name: DavinciCode
Enter the IsBn: 101
Enter the No of Pages: 500
Enter the Price: 600.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 2
Name: Avathar
Enter the IsBn: 123321
Enter the No of Pages: 600
Enter the Price: 800.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 3
Name: Avanish
Enter the IsBn: 606
Enter the No of Pages: 800
Enter the Price: 500.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 4
Name: Nagas
Enter the IsBn: 909
Enter the No of Pages: 650
Enter the Price: 850.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 5
Name: Papillon
Enter the IsBn: 424
Enter the No of Pages: 1800
Enter the Price: 5000.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

After arranging the books in ascending order
Book details

Details of Book 1
Name: DavinciCode
Enter the IsBn: 101
Enter the No of Pages: 500
Enter the Price: 600.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 2
Name: Papillon
Enter the IsBn: 424
Enter the No of Pages: 1800
Enter the Price: 5000.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 3
Name: Avanish
Enter the IsBn: 606
Enter the No of Pages: 800
Enter the Price: 500.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 4
Name: Nagas
Enter the IsBn: 909
Enter the No of Pages: 650
Enter the Price: 850.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

Details of Book 5
Name: Avathar
Enter the IsBn: 123321
Enter the No of Pages: 600
Enter the Price: 800.000000
+++++++++++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Enter the isbn number of book to search: 424
Details of Book of required ISBN number is:
Book found
Name= Papillon
ISBN= 424
Number of pages=1800
Price= 5000.000000
-----------------------------------------------------------------------------------------------------------

Details of books whose ISBN is a palindrome are:


Name            ISBN    Number of pages     Price
DavinciCode     101           500         600.000000
Papillon        424           1800        5000.000000
Avanish         606           800         500.000000
Nagas           909           650         850.000000
Avathar         123321        600         800.000000
-------------------------------------------------------------------------------------------
Process returned 0 (0x0)   execution time : 1135.032 s
Press any key to continue.


Write a Modular C Programming code for Finding the Block-chain compare, search, string
Blockchain is the new technology in computer science, where it is used to store the
‘n’ transaction details of users. Shivam is very much interested in implementing
blockchain kind of technology using C programming.Transaction details contains:
Transaction_ID, sender name, receiver name, amount, time. Please help Shivam to
implement the above problem and perform the below operations.

i) Display the transaction details of particular Transaction_ID.
ii) Display the transaction details of particular user.

CODE:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct tech
{
    char s_name[10],r_name[10];
    int transaction_ID,amount,time;
}T;
void read_details(T *t,int n);
void display_details(T *t,int n);
T trans_ID(T *t,int n);
void particular_user(T *t,int n);

int main()
{
    T blockchain[10];
    T  *t;
    t=&blockchain;
    int n;
    printf("Enter total number of users present\n");
    scanf("%d",&n);
    read_details(t,n);
    display_details(t,n);
    trans_ID(t,n);
    particular_user(t,n);
    return 0;
}

void read_details(T *t,int n)
{
    int i;
    printf("Enter the sender name   reciever name   transaction ID   amount   time\n");
    for(i=0;i<n;i++) { scanf("%s %s %d %d %d",t->s_name,t->r_name,&t->transaction_ID,&t->amount,&t->time);
         t++;
    }

}
void display_details(T *t,int n)
{
    int i;
    printf("Sender name      receiver name     transaction ID      amount      time\n");
    for(i=0;i<n;i++) { printf("%s %s %d %d %d\n",t->s_name,t->r_name,t->transaction_ID,t->amount,t->time);
        t++;
    }
}
T trans_ID(T *t,int n)
{
    int i;
    int transa;
    printf("Enter the transaction ID\n");
    scanf("%d",&transa);
    for(i=0;i<n;i++) { if((t->transaction_ID) == transa)
    {

        printf("The details of the transaction ID are %s  %s  %d  %d  %d\n",t->s_name,t->r_name,t->transaction_ID,t->amount,t->time);
    }
    t++;
    }
}
void particular_user(T *t,int n)
{
    int i;
    char nam;
    printf("Enter the sender user name\n");
    scanf("%s",nam);
    for(i=0;i<n;i++) { if(strcmp(t->s_name,nam)==0)
        {
            printf("The user details are %s  %s  %s  %d  %d\n",t->s_name,t->r_name,t->transaction_ID,t->amount,t->time);
        }
        t++;
    }
}

OUTPUT

Enter total number of users present
2
Enter the sender name   reciever name   transaction ID   amount   time
elon mark 1002 300 5
bitcoin davin 102 500 3
Sender name      receiver name     transaction ID      amount      time
elon             mark              1002                300         5
bitcoin             davin              102                500         3
Enter the transaction ID
102
The details of the transaction ID are bitcoin  davin  102  500  3

Process returned -1073741819 (0xC0000005)   execution time : 43.573 s
Press any key to continue.





ALL THE CLASS CODES

#include<stdio.h>
void main()
{
    int a[100][100],n;
    int i,j,key=1;
    printf("Enter size of matrix\n");
    scanf("%d",&n);
    printf("Enter the matrix\n");
    for(i=0;i<n;i++)
    for(j=0;j<n;j++)
    scanf("%d",&a[i][j]);
    for(i=0;i<n;i++)
    {
    for(j=0;j<n;j++)
    {
        if (a[i][j]!=a[j][i])
        {
          key=0;
        }
    }
    }
    if(key==1)
    printf("The given matrix is symmetric\n");
    else
    printf("The given matrix is not symmetric\n");

}



#include<stdio.h>
void main()
{
    int a[25];
    int i,j,c=0;
    printf("Enter array\n");
    for(i=0;i<25;i++)
    scanf("%d",&a[i]);
    for(i=0;i<25;i++)
    {
        for(j=0;j<25;j++)
        {
            if(a[i]==a[j])
            c++;
        }
        printf("The number %d is repeated for %d\n",a[i],c);
        c=0;
    }



}







#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100

int stack[MAX_SIZE];
int top = -1;

void push(int element);
int pop();
void display();

int main() {
    int choice, element;
    char inputFileName[100], outputFileName[100];
    FILE *inputFile, *outputFile;

    printf("Enter the input file name: ");
    scanf("%s", inputFileName);
    inputFile = fopen(inputFileName, "r");
    if (inputFile == NULL) {
        printf("Error opening input file!\n");
        return 1;
    }

    printf("Enter the output file name: ");
    scanf("%s", outputFileName);
    outputFile = fopen(outputFileName, "w");
    if (outputFile == NULL) {
        printf("Error opening output file!\n");
        fclose(inputFile);
        return 1;
    }

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Display\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                fscanf(inputFile, "%d", &element);
                push(element);
                fprintf(outputFile, "Pushed element: %d\n", element);
                break;
            case 2:
                element = pop();
                if (element != -1)
                    fprintf(outputFile, "Popped element: %d\n", element);
                break;
            case 3:
                display();
                fprintf(outputFile, "Stack elements:\n");
                for (int i = top; i >= 0; i--) {
                    fprintf(outputFile, "%d\n", stack[i]);
                }
                break;
            case 4:
                printf("Exiting...\n");
                fclose(inputFile);
                fclose(outputFile);
                return 0;
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    }
}

void push(int element) {
    if (top >= MAX_SIZE - 1) {
        printf("Stack Overflow! Cannot push element.\n");
    } else {
        stack[++top] = element;
        printf("Element %d pushed to stack.\n", element);
    }
}

int pop() {
    if (top == -1) {
        printf("Stack Underflow! Cannot pop element.\n");
        return -1;
    } else {
        int element = stack[top--];
        return element;
    }
}

void display() {
    if (top == -1) {
        printf("Stack is empty.\n");
    } else {
        printf("Stack elements:\n");
        for (int i = top; i >= 0; i--) {
            printf("%d\n", stack[i]);
        }
    }
}





#include<stdio.h>
#include<stdlib.h>

struct Node
{
    char name[20];
    int rno;
    struct Node *next;
};

typedef struct Node* node;
node head, newnode, temp, cur;

node getnode();
node read_details(node newnode);
node insertend(node head);
node insertbeg(node head);
node insertpos(node head);
node deleteend(node head);
node deletebeg(node head);
node deletepos(node head);
void display(node head);

int main()
{
    int choice;
    while(1)
    {
        printf("\n1->Insert at the end\n2->Insert at the beginning\n3->Insert at a specified position\n4->Display\n5->Delete from the end\n6->Delete from the beginning\n7->Delete from a specified position\n8->Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        
        switch(choice)
        {
            case 1:
                head = insertend(head);
                break;
            case 2:
                head = insertbeg(head);
                break;
            case 3:
                head = insertpos(head);
                break;
            case 4:
                display(head);
                break;
            case 5:
                head = deleteend(head);
                break;
            case 6:
                head = deletebeg(head);
                break;
            case 7:
                head = deletepos(head);
                break;
            case 8:
                exit(0);
            default:
                printf("Invalid input\n");
                break;
        }
    }
}

node getnode()
{
    newnode = (node)malloc(sizeof(struct Node));
    if (newnode == NULL)
    {
        printf("Memory not allocated\n");
        exit(0);
    }
    return newnode;
}

node read_details(node newnode)
{
    printf("Enter the name and roll no: ");
    scanf("%s%d", newnode->name, &newnode->rno);
    newnode->next = NULL;
    return newnode;
}

node insertend(node head)
{
    newnode = getnode();
    newnode = read_details(newnode);
    if (head == NULL)
    {
        head = newnode;
        return head;
    }
    else
    {
        temp = head;
        while (temp->next != NULL)
        {
            temp = temp->next;
        }
        temp->next = newnode;
        return head;
    }
}

node insertbeg(node head)
{
    newnode = getnode();
    newnode = read_details(newnode);
    if (head == NULL)
    {
        head = newnode;
        return head;
    }
    else
    {
        newnode->next = head;
        head = newnode;
        return head;
    }
}

node insertpos(node head)
{
    int pos, i;
    printf("Enter the position to insert the node: ");
    scanf("%d", &pos);
    if (pos < 1)
    {
        printf("Invalid position\n");
        return head;
    }

    if (pos == 1)
    {
        head = insertbeg(head);
        return head;
    }
    else
    {
        temp = head;
        for (i = 1; i < pos - 1 && temp != NULL; i++)
        {
            temp = temp->next;
        }
        if (temp == NULL)
        {
            printf("Position exceeds the length of the list\n");
            return head;
        }
        else
        {
            newnode = getnode();
            newnode = read_details(newnode);
            newnode->next = temp->next;
            temp->next = newnode;
            return head;
        }
    }
}

void display(node head)
{
    if (head == NULL)
    {
        printf("Linked list is empty\n");
    }
    else
    {
        temp = head;
        while (temp != NULL)
        {
            printf("%s%d->", temp->name, temp->rno);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

node deleteend(node head)
{
    if (head == NULL)
    {
        printf("Linked list is empty\n");
        return head;
    }
    else
    {
        if (head->next == NULL)
        {
            printf("Deleted: %s%d\n", head->name, head->rno);
            free(head);
            head = NULL;
            return head;
        }
        else
        {
            temp = head;
            cur = head->next;
            while (cur->next != NULL)
            {
                temp = temp->next;
                cur = cur->next;
            }
            printf("Deleted: %s%d\n", cur->name, cur->rno);
            free(cur);
            temp->next = NULL;
            return head;
        }
    }
}

node deletebeg(node head)
{
    if (head == NULL)
    {
        printf("Linked list is empty\n");
        return head;
    }
    else
    {
        temp = head;
        head = head->next;
        printf("Deleted: %s%d\n", temp->name, temp->rno);
        free(temp);
        return head;
    }
}

node deletepos(node head)
{
    int pos, i;
    printf("Enter the position to delete the node: ");
    scanf("%d", &pos);
    if (pos < 1)
    {
        printf("Invalid position\n");
        return head;
    }

    if (pos == 1)
    {
        head = deletebeg(head);
        return head;
    }
    else
    {
        temp = head;
        for (i = 1; i < pos - 1 && temp != NULL; i++)
        {
            temp = temp->next;
        }
        if (temp == NULL || temp->next == NULL)
        {
            printf("Position exceeds the length of the list\n");
            return head;
        }
        else
        {
            cur = temp->next;
            temp->next = cur->next;
            printf("Deleted: %s%d\n", cur->name, cur->rno);
            free(cur);
            return head;
        }
    }
}




#include <stdio.h>

#define MAX_LINE_LENGTH 1000 // maximum length of a line


int main() {
    char line[];
    char longest_line[MAX_LINE_LENGTH];
    int max_length = 0;
    int i;
   n ant vand variable declare maadi read madri amele use this code
    // Read 10 lines from the user input
    for (i = -1; i < n; i++) {
        int length = 0;
        char c;
        
        // Read characters until end-of-line or end-of-file is reached
        while ((c = getchar())) {
            line[length++] = c;
        }
        
        // Add null terminator to the line
        line[length] = '\0';
        
        // Check if this line is the longest so far
        if (length > max_length) {
            max_length = length;
            
            // Copy the longest line to longest_line array
            int j;
            for (j = 0; j <= length; j++) {
                longest_line[j] = line[j];
            }
        }
    }
    
    // Print the longest line
    printf("The longest line is:\n%s", longest_line);
    
    return 0;
}










#include<stdio.h>
#include<stdlib.h>
void compare(char str[10][100]);
int count(char str[]);

int main()
{
 FILE *s,*c;
 char str[10][100];
 s=fopen("test.txt","r");
 for(int i=0;i<10;i++)
 {
     fgets(str[i],264,s);
 }
 compare(str);
 c=fopen("test1.txt","w");
 for(int i=0;i<10;i++)
 {
     fputs(str[i],c);
 }

 fclose(s);
 fclose(c);
 return 0;
}
int count(char str[])
{
    int i,countt=0;
    while(str[i]!='\0')
    {
        countt++;
        i++;
    }
    return countt;
}
void compare(char str[10][100])
{
    int c=0,m,k,i;
    char a[100];
    for(i=0;i<10;i++)
    {
       if(m=count(str[i])>c)
        {
            c=count(str[i]);
           k=i;
        }
    }
   printf("\n longest is \n %s\n",str[k]);
}





#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void readm(int *r1,int *c1,int a[][10]);
void matr(int *r1,int *c1,int a[][10]);
void mult(int *r1,int *c1,int *r2,int *c2,int a[][10],int b[][10],int c[][10]);
void main()
{
    int a[10][10],b[10][10],c[10][10];
    int r1,c1,r2,c2;
    printf(" enter order of 1st matrix\n");
    scanf("%d\t%d",&r1,&c1);
    if(r1<1||c1<1||r1>10||c1>10)
    {
        printf("invalid order of 1st matrix");
        exit(0);
    }
    printf("enter 1st matrix \n");
    readm(&r1,&c1,a);
    printf(" enter order of 2nd matrix\n");
    scanf("%d\t%d",&r2,&c2);
    if(r2<1||c2<1||r2>10||c2>10)
    {
        printf("invalid order of 1st matrix");
        exit(0);
    }
    printf("enter 2nd matrix \n");
    readm(&r2,&c2,b);
    printf(" the 1st matrix is:\n");
    matr(&r1,&c1,a);
    printf(" the 2nd matrix is:\n");
    matr(&r2,&c2,b);
    mult(&r1,&c1,&r2,&c2,a,b,c);
    printf(" multiplied matrix is:\n");
    matr(&r1,&c2,c);
    return;
}
void readm(int *r1,int *c1,int a[][10])
{
    int i,j;
    for(i=0;i<*r1;i++)
    {
        for(j=0;j<*c1;j++)
        {
            scanf("%d",(*(a+i)+j));
        }
    }
    return;
}
void matr(int *r1,int *c1,int a[][10])
{
    int i,j;
    for(i=0;i<*r1;i++)
    {
        printf("\n");
        for(j=0;j<*c1;j++)
        {
            printf("%d\t",((a+i)+j));
        }
    }
    printf("\n");
    return;
}
void mult(int *r1,int *c1,int *r2,int *c2,int a[][10],int b[][10],int c[][10])
{
    int i,j,k;
    if(*c1!=*r2)
    {
        printf(" order not compatible to find product\n");
        exit(0);
    }
    for(i=0;i<*r1;i++)
    {
        for(j=0;j<*c2;j++)
        {
            c[i][j]=0;
            for(k=0;k<*c2;k++)
            {
                c[i][j]=c[i][j]+a[i][k]*b[k][j];
            }
        }
    }
    return;
}



#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
void bubblesort();
void selectionsort();
int main()
{
    int l,u,N,num,i;
    float duration;
    clock_t start,end;
    FILE *fp;
    printf("\nenter range lower and upper:");
    scanf("%d%d",&l,&u);
    printf("\nenter count:");
    scanf("%d",&N);
    fp=fopen("inp.txt","w");
    if(fp==NULL)
    {
        printf("\nerror");
        exit(0);
    }
    srand(time(0));
    printf("\nThe random numbers are: ");
    for(i=0;i<N;i++)
    {
        num=(rand() % (u-l+1))+l;
        printf("\n%d",num);
        fprintf(fp,"%d ",num);
    }
    printf("\n\nNumbers have been printed in file successfully\n");
    fclose(fp);
    start=clock();
    bubblesort();
    end=clock();
    duration=(float)(end-start);
    printf("\n\n\nduration for bubble sort%f",duration);

    start=clock();
    selectionsort();
    end=clock();
    duration=(float)(end-start);
    printf("\n\n\nduration for selection sort%f",duration);
}
void bubblesort()
{
    int arr[100],i,n=0,j,temp,s=0;
    FILE *fp1,*fp2;
     fp1=fopen("inp.txt","r");
    if(fp1==NULL)
    {
        printf("\nerror");
        exit(0);
    }
     fp2=fopen("out.txt","w");
    if(fp2==NULL)
    {
        printf("\nerror");
        exit(0);
    }
    while(fscanf(fp1,"%d",&arr[s])==1)
    {
      s++;
      n++;
    }
    for(s=0;s<n;s++)
      {
          printf("\nNumbers in array:%d\t",arr[s]);
      }
       fclose(fp1);
      for(i=0;i<n-1;i++)
      {
          for(j=0;j<n-i-1;j++)
          {
              if(arr[j]>arr[j+1])
              {
                  temp=arr[j];
                  arr[j]=arr[j+1];
                  arr[j+1]=temp;
              }
          }
      }
      for(s=0;s<n;s++)
      {
          printf("\n\nsorted array%d\t",arr[s]);
          fprintf(fp2,"%d\t",arr[s]);
      }
      fclose(fp2);
}

void selectionsort()
{
    int arr[100],i,n=0,j,temp,s=0,x,r;
    FILE *fp1,*fp2;
     fp1=fopen("inp.txt","r");
    if(fp1==NULL)
    {
        printf("\nerror");
        exit(0);
    }
     fp2=fopen("out.txt","w");
    if(fp2==NULL)
    {
        printf("\nerror");
        exit(0);
    }
    while(fscanf(fp1,"%d",&arr[s])==1)
    {
      s++;
      n++;
    }
    for(s=0;s<n;s++)
      {
          printf("\nNumbers in array:%d\t",arr[s]);
      }
       fclose(fp1);
      for(i=0;i<n-1;i++)
      {
          x=arr[i];
          for(j=i+1;j<n;j++)
          {
              if(arr[j]<x)
              {
                  x=arr[j];
                  r=j;
              }
          }
          temp=arr[i];
          arr[i]=x;
          arr[r]=temp;
      }
      for(s=0;s<n;s++)
      {
          printf("\n\nsorted array%d\t",arr[s]);
          fprintf(fp2,"%d\t",arr[s]);
      }
      fclose(fp2);
}





Write a Modular C Programming code for Getting details of a Student who took the highest marks.
Read the number of students, read their information and display the details of the students:

CODE:

#include<stdio.h>
struct cricket_player
{
    char name[20];
    char nationality[20];
    int ranking;
    int total_runs;
    int no_of_wickets;
};
void readStructure(struct cricket_player *p,int n);
void displayStructure(struct cricket_player *p,int n);
void leastRank(struct cricket_player *p,int n);
void totalWickets(struct cricket_player *p,int n);
void runs(struct cricket_player *p,int n);
main()
{
    int n;
    struct cricket_player cp[1000];
    struct cricket_player *p;
    p=&cp;
    printf("Enter the number of players: ");
    scanf("%d",&n);
    readStructure(p,n);
    leastRank(p,n);
    totalWickets(p,n);
    runs(p,n);
}
void readStructure(struct cricket_player *p,int n)
{
    int i;
    for(i=0;i<n;i++) { printf("\nEnter Details of Player %d",i+1); printf("\nEnter the Name: "); scanf("%s",&(p+i)->name);
printf("Enter the Nationality: ");
scanf("%s",&(p+i)->nationality);
printf("Enter the Ranking: ");
scanf("%d",&(p+i)->ranking);
printf("Enter the Total Runs: ");
scanf("%d",&(p+i)->total_runs);
printf("Enter the Number of Wickets: ");
scanf("%d",&(p+i)->no_of_wickets);
printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n");
    }
}
void displayStructure(struct cricket_player *p,int n)
{
printf("\nName: %s",(p+n)->name);
printf("\nNationality: %s",(p+n)->nationality);
printf("\nRanking: %d",(p+n)->ranking);
printf("\nTotal Runs: %d",(p+n)->total_runs);
printf("\nNumber of Wickets: %d",(p+n)->no_of_wickets);
printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n");

}
void totalWickets(struct cricket_player *p,int n)
{
    int i;
    int sum=0;
    for(i=0;i<n;i++) { sum=sum+(p+i)->no_of_wickets;
    }
    printf("\n\nTotal number of wickets = %d\n",sum);
}
void leastRank(struct cricket_player *p,int n)
{
    int i,k;
    int min=p->ranking;
    for(i=0;i<n;i++) { if((p+i)->ranking<min) { min=(p+i)->ranking;
            k=i;
        }
    }
    printf("\nDetails of player with least ranking:\n");
    displayStructure(p,k);
}
void runs(struct cricket_player *p,int n)
{
    int i;
    printf("Details of players with runs more than 5000:\n");
    for(i=0;i<n;i++) { if((p+i)->total_runs>5000)
           displayStructure(p,i);
    }
}

OUTPUT

Enter the number of players: 5

Enter Details of Player 1
Enter the Name: Jimmy
Enter the Nationality: Usa
Enter the Ranking: 8
Enter the Total Runs: 5904
Enter the Number of Wickets: 23

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Player 2
Enter the Name: Gyann
Enter the Nationality: India
Enter the Ranking: 8
Enter the Total Runs: 653
Enter the Number of Wickets: 43456

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Player 3
Enter the Name: grthy
Enter the Nationality: 7657
Enter the Ranking: 767
Enter the Total Runs: 34555556
Enter the Number of Wickets: 324

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Player 4
Enter the Name: gthjfg
Enter the Nationality: retqrt
Enter the Ranking: 3
Enter the Total Runs: 456543
Enter the Number of Wickets: 45

+++++++++++++++++++++++++++++++++++++++++++++++++

Enter Details of Player 5
Enter the Name: AnarDreams
Enter the Nationality: Habibi
Enter the Ranking: 1
Enter the Total Runs: 34563
Enter the Number of Wickets: 234567898765

+++++++++++++++++++++++++++++++++++++++++++++++++

Details of player with least ranking:

Name: AnarDreams
Nationality: Habibi
Ranking: 1
Total Runs: 34563
Number of Wickets: -1655302515
+++++++++++++++++++++++++++++++++++++++++++++++++


Total number of wickets = -1655258667
Details of players with runs more than 5000:

Name: Jimmy
Nationality: Usa
Ranking: 8
Total Runs: 5904
Number of Wickets: 23
+++++++++++++++++++++++++++++++++++++++++++++++++

Name: grthy
Nationality: 7657
Ranking: 767
Total Runs: 34555556
Number of Wickets: 324
+++++++++++++++++++++++++++++++++++++++++++++++++

Name: gthjfg
Nationality: retqrt
Ranking: 3
Total Runs: 456543
Number of Wickets: 45
+++++++++++++++++++++++++++++++++++++++++++++++++

Name: AnarDreams
Nationality: Habibi
Ranking: 1
Total Runs: 34563
Number of Wickets: -1655302515
+++++++++++++++++++++++++++++++++++++++++++++++++

Process returned 0 (0x0)   execution time : 447.635 s
Press any key to continue.
















